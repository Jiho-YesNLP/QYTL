[{"text": "Hi, I\u2019m Carrie Anne and this is Crash Course\nComputer Science!", "start": 3.02, "duration": 3.12}, {"text": "Last episode, we combined an ALU, control\nunit, some memory, and a clock together to", "start": 6.14, "duration": 3.93}, {"text": "make a basic, but functional Central Processing\nUnit \u2013 or CPU \u2013 the beating, ticking heart", "start": 10.07, "duration": 4.71}, {"text": "of a computer.", "start": 14.78, "duration": 1.02}, {"text": "We\u2019ve done all the hard work of building\nmany of these components from the electronic", "start": 15.8, "duration": 3.729}, {"text": "circuits up, and now it\u2019s time to give our\nCPU some actual instructions to process!", "start": 19.529, "duration": 4.371}, {"text": "The thing that makes a CPU powerful is the\nfact that it is programmable \u2013 if you write", "start": 23.9, "duration": 4.289}, {"text": "a different sequence of instructions, then\nthe CPU will perform a different task.", "start": 28.189, "duration": 3.67}, {"text": "So the CPU is a piece of hardware which is\ncontrolled by easy-to-modify software!", "start": 31.86, "duration": 4.34}, {"text": "INTRO", "start": 36.2, "duration": 8.68}, {"text": "Let\u2019s quickly revisit the simple program\nthat we stepped through last episode.", "start": 44.88, "duration": 3.73}, {"text": "The computer memory looked like this.", "start": 48.61, "duration": 2.13}, {"text": "Each address contained 8 bits of data.", "start": 50.74, "duration": 1.63}, {"text": "For our hypothetical CPU, the first four bits\nspecified the operation code, or opcode, and", "start": 52.37, "duration": 5.6}, {"text": "the second set of four bits specified an address\nor registers.", "start": 57.97, "duration": 2.95}, {"text": "In memory address zero we have 0010 1110.", "start": 60.92, "duration": 3.61}, {"text": "Again, those first four bits are our opcode\nwhich corresponds to a \u201cLOAD_A\u201d instruction.", "start": 64.53, "duration": 5.699}, {"text": "This instruction reads data from a location\nof memory specified in those last four bits", "start": 70.229, "duration": 4.74}, {"text": "of the instruction and saves it into Register\nA. In this case, 1110, or 14 in decimal.", "start": 74.969, "duration": 6.271}, {"text": "So let\u2019s not think of this of memory address\n0 as \u201c0010 1110\u201d, but rather as the instruction", "start": 81.24, "duration": 6.44}, {"text": "\u201cLOAD_A 14\u201d.", "start": 87.68, "duration": 1.0}, {"text": "That\u2019s much easier to read and understand!", "start": 88.68, "duration": 2.009}, {"text": "And for me to say!", "start": 90.689, "duration": 1.231}, {"text": "And we can do the same thing for the rest\nof the data in memory.", "start": 91.92, "duration": 3.22}, {"text": "In this case, our program is just four instructions\nlong, and we\u2019ve put some numbers into memory", "start": 95.14, "duration": 4.11}, {"text": "too, 3 and 14.", "start": 99.25, "duration": 2.249}, {"text": "So now let\u2019s step through this program:", "start": 101.499, "duration": 1.32}, {"text": "First is LOAD_A 14, which takes the value\nin address 14, which is the number 3, and", "start": 102.819, "duration": 4.89}, {"text": "stores it into Register A.", "start": 107.709, "duration": 1.36}, {"text": "Then we have a \u201cLOAD_B 15\u201d instruction,\nwhich takes the value in memory location 15,", "start": 109.069, "duration": 4.97}, {"text": "which is the number 14, and saves it into\nRegister B.", "start": 114.039, "duration": 2.5}, {"text": "Okay.", "start": 116.54, "duration": 1.0}, {"text": "Easy enough.", "start": 117.54, "duration": 0.9}, {"text": "But now we have an \u201cADD\u201d instruction.", "start": 118.62, "duration": 1.7}, {"text": "This tells the processor to use the ALU to\nadd two registers together, in this case,", "start": 120.32, "duration": 4.619}, {"text": "B and A are specified.", "start": 124.94, "duration": 1.7}, {"text": "The ordering is important, because the resulting sum is saved into the second register that\u2019s specified.", "start": 126.64, "duration": 5.2}, {"text": "So in this case, the resulting sum is saved\ninto Register A.", "start": 131.84, "duration": 3.36}, {"text": "And finally, our last instruction is \u201cSTORE_A\n13\u201d, which instructs the CPU to write whatever", "start": 135.2, "duration": 4.61}, {"text": "value is in Register A into memory location\n13.", "start": 139.81, "duration": 3.64}, {"text": "Yesss!", "start": 143.45, "duration": 1.0}, {"text": "Our program adds two numbers together.", "start": 144.45, "duration": 1.55}, {"text": "That\u2019s about as exciting as it gets when\nwe only have four instructions to play with.", "start": 146.0, "duration": 4.17}, {"text": "So let\u2019s add some more!", "start": 150.17, "duration": 1.01}, {"text": "Now we\u2019ve got a subtract function, which\nlike ADD, specifies two registers to operate on.", "start": 151.18, "duration": 4.5}, {"text": "We\u2019ve also got a fancy new instruction called\nJUMP.", "start": 155.72, "duration": 2.58}, {"text": "As the name implies, this causes the program\nto \u201cjump\u201d to a new location.", "start": 158.3, "duration": 3.74}, {"text": "This is useful if we want to change the order\nof instructions, or choose to skip some instructions.", "start": 162.04, "duration": 3.34}, {"text": "For example, a JUMP 0, would cause the program\nto go back to the beginning.", "start": 165.38, "duration": 3.57}, {"text": "At a low level, this is done by writing the\nvalue specified in the last four bits into", "start": 168.95, "duration": 4.33}, {"text": "the instruction address register, overwriting\nthe current value.", "start": 173.28, "duration": 3.29}, {"text": "We\u2019ve also added a special version of JUMP\ncalled JUMP_NEGATIVE.", "start": 176.57, "duration": 3.83}, {"text": "This only jumps the program if the ALU\u2019s\nnegative flag is set to true.", "start": 180.4, "duration": 3.77}, {"text": "As we talked about in Episode 5, the negative\nflag is only set when the result of an arithmetic", "start": 184.17, "duration": 4.73}, {"text": "operation is negative.", "start": 188.9, "duration": 1.68}, {"text": "If the result of the arithmetic was zero or\npositive, the negative flag would not be set.", "start": 190.58, "duration": 3.56}, {"text": "So the JUMP NEGATIVE won\u2019t jump anywhere, and the CPU will just continue on to the next instruction.", "start": 194.14, "duration": 5.12}, {"text": "And finally, computers need to be told when\nto stop processing, so we need a HALT instruction.", "start": 199.32, "duration": 4.84}, {"text": "Our previous program really should have looked\nlike this to be correct, otherwise the CPU", "start": 204.22, "duration": 3.87}, {"text": "would have just continued on after the STORE\ninstruction, processing all those 0\u2019s.", "start": 208.09, "duration": 4.34}, {"text": "But there is no instruction with an opcode\nof 0, and so the computer would have crashed!", "start": 212.43, "duration": 4.15}, {"text": "It\u2019s important to point out here that we\u2019re\nstoring both instructions and data in the", "start": 216.58, "duration": 3.84}, {"text": "same memory.", "start": 220.42, "duration": 1.0}, {"text": "There is no difference fundamentally -- it\u2019s\nall just binary numbers.", "start": 221.42, "duration": 2.43}, {"text": "So the HALT instruction is really important\nbecause it allows us to separate the two.", "start": 223.85, "duration": 3.83}, {"text": "Okay, so let\u2019s make our program a bit more\ninteresting, by adding a JUMP.", "start": 227.68, "duration": 3.96}, {"text": "We\u2019ll also modify our two starting values\nin memory to 1 and 1.", "start": 231.64, "duration": 3.84}, {"text": "Lets step through this program just as our\nCPU would.", "start": 235.48, "duration": 2.81}, {"text": "First, LOAD_A 14 loads the value 1 into Register A.", "start": 238.29, "duration": 3.19}, {"text": "Next, LOAD_B 15 loads the value 1 into Register B.", "start": 241.48, "duration": 3.89}, {"text": "As before, we ADD registers B and A together,\nwith the sum going into Register A. 1+1 = 2,", "start": 245.37, "duration": 5.65}, {"text": "so now Register A has the value 2 in it (stored\nin binary of course)", "start": 251.02, "duration": 4.14}, {"text": "Then the STORE instruction saves that into\nmemory location 13.", "start": 255.16, "duration": 3.56}, {"text": "Now we hit a \u201cJUMP 2\u201d instruction.", "start": 258.72, "duration": 2.06}, {"text": "This causes the processor to overwrite the\nvalue in the instruction address register,", "start": 260.78, "duration": 4.07}, {"text": "which is currently 4, with the new value, 2.", "start": 264.85, "duration": 2.2}, {"text": "Now, on the processor\u2019s next fetch cycle,\nwe don\u2019t fetch HALT, instead we fetch the", "start": 267.05, "duration": 4.42}, {"text": "instruction at memory location 2, which is\nADD B A.", "start": 271.47, "duration": 2.67}, {"text": "We\u2019ve jumped!", "start": 274.14, "duration": 1.02}, {"text": "Register A contains the value 2, and register\nB contains the value 1.", "start": 275.16, "duration": 3.74}, {"text": "So 1+2 = 3, so now Register A has the value 3.", "start": 278.9, "duration": 4.03}, {"text": "We store that into memory.", "start": 282.93, "duration": 1.59}, {"text": "And we\u2019ve hit the JUMP again, back to ADD\nB A.", "start": 284.52, "duration": 3.02}, {"text": "1+3 = 4.", "start": 287.54, "duration": 1.5}, {"text": "So now register A has the value 4.", "start": 289.04, "duration": 2.15}, {"text": "See what's happening here?", "start": 291.19, "duration": 1.21}, {"text": "Every loop, we\u2019re adding one.", "start": 292.42, "duration": 1.44}, {"text": "Its counting up!", "start": 293.87, "duration": 0.99}, {"text": "Cooooool.", "start": 294.87, "duration": 1.0}, {"text": "But notice there\u2019s no way to ever escape.", "start": 295.87, "duration": 1.6}, {"text": "We\u2019re never.. ever.. going to get to that\nhalt instruction, because we\u2019re always going", "start": 297.47, "duration": 3.72}, {"text": "to hit that JUMP.", "start": 301.19, "duration": 1.16}, {"text": "This is called an infinite loop \u2013 a program\nthat runs forever\u2026 ever\u2026 ever\u2026 ever\u2026", "start": 302.35, "duration": 4.92}, {"text": "ever", "start": 307.27, "duration": 0.65}, {"text": "To break the loop, we need a conditional jump.", "start": 308.0, "duration": 2.04}, {"text": "A jump that only happens if a certain condition is met.", "start": 310.04, "duration": 3.15}, {"text": "Our JUMP_NEGATIVE is one example of a conditional\njump, but computers have other types too - like", "start": 313.19, "duration": 5.37}, {"text": "JUMP IF EQUAL and JUMP IF GREATER.", "start": 318.56, "duration": 2.28}, {"text": "So let\u2019s make our code a little fancier\nand step through it.", "start": 320.84, "duration": 3.55}, {"text": "Just like before, the program starts by loading\nvalues from memory into registers A and B.", "start": 324.39, "duration": 4.33}, {"text": "In this example, the number 11 gets loaded\ninto Register A, and 5 gets loaded into Register B.", "start": 328.72, "duration": 5.38}, {"text": "Now we subtract register B from register A.\nThat\u2019s 11 minus 5, which is 6, and so 6", "start": 334.1, "duration": 5.52}, {"text": "gets saved into Register A.", "start": 339.62, "duration": 1.23}, {"text": "Now we hit our JUMP NEGATIVE.", "start": 340.85, "duration": 1.7}, {"text": "The last ALU result was 6.", "start": 342.55, "duration": 1.83}, {"text": "That\u2019s a positive number, so the the negative\nflag is false.", "start": 344.38, "duration": 3.28}, {"text": "That means the processor does not jump.", "start": 347.66, "duration": 1.96}, {"text": "So we continue on to the next instruction...", "start": 349.62, "duration": 1.96}, {"text": "...which is a JUMP 2.", "start": 351.58, "duration": 1.06}, {"text": "No conditional on this one, so we jump to\ninstruction 2 no matter what.", "start": 352.64, "duration": 3.76}, {"text": "Ok, so we\u2019re back at our SUBTRACT Register\nB from Register A. 6 minus 5 equals 1.", "start": 356.44, "duration": 4.98}, {"text": "So 1 gets saved into register A.", "start": 361.42, "duration": 1.84}, {"text": "Next instruction.", "start": 363.26, "duration": 1.0}, {"text": "We\u2019re back again at our JUMP NEGATIVE.", "start": 364.26, "duration": 1.78}, {"text": "1 is also a positive number, so the CPU continues\non to the JUMP 2, looping back around again", "start": 366.04, "duration": 5.89}, {"text": "to the SUBTRACT instruction.", "start": 371.93, "duration": 1.75}, {"text": "This time is different though.", "start": 373.68, "duration": 1.29}, {"text": "1 minus 5 is negative 4.", "start": 374.97, "duration": 2.38}, {"text": "And so the ALU sets its negative flag to true\nfor the first time.", "start": 377.35, "duration": 3.34}, {"text": "Now, when we advance to the next instruction,", "start": 380.69, "duration": 2.57}, {"text": "JUMP_NEGATIVE 5, the CPU executes the jump\nto memory location 5.", "start": 383.26, "duration": 4.14}, {"text": "We\u2019re out of the infinite loop!", "start": 387.4, "duration": 1.76}, {"text": "Now we have a ADD B to A. Negative 4 plus\n5, is positive 1, and we save that into Register A.", "start": 389.16, "duration": 6.34}, {"text": "Next we have a STORE instruction that saves\nRegister A into memory address 13.", "start": 395.5, "duration": 4.26}, {"text": "Lastly, we hit our HALT instruction and the\ncomputer rests.", "start": 399.76, "duration": 3.9}, {"text": "So even though this program is only 7 instructions\nlong, the CPU ended up executing 13 instructions,", "start": 403.66, "duration": 6.09}, {"text": "and that's because it looped twice internally.", "start": 409.75, "duration": 2.29}, {"text": "This code calculated the remainder if we divide\n5 into 11, which is one.", "start": 412.04, "duration": 4.34}, {"text": "With a few extra lines of code, we could also\nkeep track of how many loops we did, the count", "start": 416.38, "duration": 4.28}, {"text": "of which would be how many times 5 went into\n11\u2026 we did two loops, so that means 5 goes", "start": 420.66, "duration": 5.069}, {"text": "into 11 two times... with a remainder of 1.", "start": 425.729, "duration": 2.741}, {"text": "And of course this code could work for any\ntwo numbers, which we can just change in memory", "start": 428.47, "duration": 3.979}, {"text": "to whatever we want: 7 and 81, 18 and 54,\nit doesn\u2019t matter -- that\u2019s the power", "start": 432.449, "duration": 4.831}, {"text": "of software!", "start": 437.28, "duration": 1.0}, {"text": "Software also allowed us to do something our\nhardware could not.", "start": 438.28, "duration": 3.2}, {"text": "Remember, our ALU didn\u2019t have the functionality\nto divide two numbers, instead it\u2019s the", "start": 441.48, "duration": 4.76}, {"text": "program we made that gave us that functionality.", "start": 446.24, "duration": 2.53}, {"text": "And then other programs can use our divide\nprogram to do even fancier things.", "start": 448.77, "duration": 3.959}, {"text": "And you know what that means.", "start": 452.729, "duration": 1.411}, {"text": "New levels of abstraction!", "start": 454.14, "duration": 7.64}, {"text": "So, our hypothetical CPU is very basic \u2013 all\nof its instructions are 8 bits long, with", "start": 461.78, "duration": 4.74}, {"text": "the opcode occupying only the first four bits.", "start": 466.521, "duration": 3.179}, {"text": "So even if we used every combination of 4\nbits, our CPU would only be able to support", "start": 469.7, "duration": 4.67}, {"text": "a maximum of 16 different instructions.", "start": 474.37, "duration": 2.42}, {"text": "On top of that, several of our instructions\nused the last 4 bits to specify a memory location.", "start": 476.79, "duration": 4.93}, {"text": "But again, 4 bits can only encode 16 different\nvalues, meaning we can address a maximum of", "start": 481.72, "duration": 4.919}, {"text": "16 memory locations - that\u2019s not a lot to work with.", "start": 486.64, "duration": 3.57}, {"text": "For example, we couldn\u2019t even JUMP to location\n17, because we literally can\u2019t fit the number", "start": 490.21, "duration": 4.91}, {"text": "17 into 4 bits.", "start": 495.12, "duration": 1.71}, {"text": "For this reason, real, modern CPUs use two\nstrategies.", "start": 496.83, "duration": 3.01}, {"text": "The most straightforward approach is just\nto have bigger instructions, with more bits,", "start": 499.84, "duration": 4.01}, {"text": "like 32 or 64 bits.", "start": 503.85, "duration": 2.07}, {"text": "This is called the instruction length.", "start": 505.92, "duration": 2.32}, {"text": "Unsurprisingly.", "start": 508.24, "duration": 1.0}, {"text": "The second approach is to use variable length\ninstructions.", "start": 509.24, "duration": 2.89}, {"text": "For example, imagine a CPU that uses 8 bit\nopcodes.", "start": 512.13, "duration": 3.409}, {"text": "When the CPU sees an instruction that needs\nno extra values, like the HALT instruction,", "start": 515.539, "duration": 4.511}, {"text": "it can just execute it immediately.", "start": 520.05, "duration": 1.59}, {"text": "However, if it sees something like a JUMP\ninstruction, it knows it must also fetch", "start": 521.64, "duration": 3.79}, {"text": "the address to jump to, which is saved immediately\nbehind the JUMP instruction in memory.", "start": 525.43, "duration": 4.66}, {"text": "This is called, logically enough, an Immediate\nValue.", "start": 530.09, "duration": 2.8}, {"text": "In such processor designs, instructions can\nbe any number of bytes long, which makes the", "start": 532.89, "duration": 3.96}, {"text": "fetch cycle of the CPU a tad more complicated.", "start": 536.85, "duration": 2.31}, {"text": "Now, our example CPU and instruction set is hypothetical, designed to illustrate key working", "start": 539.16, "duration": 5.36}, {"text": "principles.", "start": 544.52, "duration": 1.0}, {"text": "So I want to leave you with a real CPU example.", "start": 545.52, "duration": 2.34}, {"text": "In 1971, Intel released the 4004 processor.", "start": 547.86, "duration": 3.29}, {"text": "It was the first CPU put all into a single\nchip and paved the path to the intel processors", "start": 551.15, "duration": 4.73}, {"text": "we know and love today.", "start": 555.88, "duration": 1.28}, {"text": "It supported 46 instructions, shown here.", "start": 557.16, "duration": 2.58}, {"text": "Which was enough to build an entire working\ncomputer.", "start": 559.74, "duration": 2.49}, {"text": "And it used many of the instructions we\u2019ve\ntalked about like JUMP ADD SUBTRACT and LOAD.", "start": 562.23, "duration": 4.63}, {"text": "It also uses 8-bit immediate values, like\nwe just talked about, for things like JUMPs,", "start": 566.86, "duration": 4.85}, {"text": "in order to address more memory.", "start": 571.71, "duration": 1.55}, {"text": "And processors have come a long way since 1971.", "start": 573.26, "duration": 3.05}, {"text": "A modern computer processor, like an Intel\nCore i7, has thousands of different instructions", "start": 576.31, "duration": 4.82}, {"text": "and instruction variants, ranging from one\nto fifteen bytes long.", "start": 581.13, "duration": 3.23}, {"text": "For example, there\u2019s over a dozens different\nopcodes just for variants of ADD!", "start": 584.36, "duration": 3.65}, {"text": "And this huge growth in instruction set size\nis due in large part to extra bells and whistles", "start": 588.01, "duration": 4.49}, {"text": "that have been added to processor designs\novertime, which we\u2019ll talk about next episode.", "start": 592.51, "duration": 5.01}, {"text": "See you next week!", "start": 597.52, "duration": 1.04}]