[{"text": "Hi, I\u2019m Carrie Anne and welcome to Crash\nCourse Computer Science.", "start": 3.18, "duration": 2.6}, {"text": "So last episode, using just logic gates, we\nbuilt a simple ALU, which performs arithmetic", "start": 5.79, "duration": 5.23}, {"text": "and logic operations, hence the \u2018A\u2019 and\nthe \u2018L\u2019.", "start": 11.03, "duration": 2.939}, {"text": "But of course, there\u2019s not much point in\ncalculating a result only to throw it away", "start": 13.969, "duration": 3.391}, {"text": "- it would be useful to store that value somehow, and maybe even run several operations in a row.", "start": 17.36, "duration": 5.28}, {"text": "That's where computer memory comes in!", "start": 22.74, "duration": 2.1}, {"text": "If you've ever been in the middle of a long\nRPG campaign on your console, or slogging", "start": 24.85, "duration": 3.79}, {"text": "through a difficult level on Minesweeper on\nyour desktop, and your dog came by, tripped", "start": 28.65, "duration": 4.29}, {"text": "and pulled the power cord out of the wall,\nyou know the agony of losing all your progress.", "start": 32.94, "duration": 4.04}, {"text": "Condolences.", "start": 36.98, "duration": 1.22}, {"text": "But the reason for your loss is that your\nconsole, your laptop and your computers make", "start": 38.2, "duration": 3.8}, {"text": "use of Random Access Memory, or RAM, which\nstores things like game state - as long as", "start": 42.01, "duration": 4.53}, {"text": "the power stays on.", "start": 46.54, "duration": 1.18}, {"text": "Another type of memory, called persistent\nmemory, can survive without power, and it\u2019s", "start": 47.72, "duration": 3.94}, {"text": "used for different things; We'll talk about\nthe persistence of memory in a later episode.", "start": 51.68, "duration": 3.979}, {"text": "Today, we\u2019re going to start small - literally by building a circuit that can store one..", "start": 55.66, "duration": 4.35}, {"text": "single.. bit of information.", "start": 60.01, "duration": 1.71}, {"text": "After that, we\u2019ll scale up, and build our\nvery own memory module, and we\u2019ll combine", "start": 61.72, "duration": 4.04}, {"text": "it with our ALU next time, when we finally\nbuild our very own CPU!", "start": 65.76, "duration": 4.54}, {"text": "INTRO", "start": 70.3, "duration": 9.06}, {"text": "All of the logic circuits we've discussed\nso far go in one direction - always flowing", "start": 79.37, "duration": 3.92}, {"text": "forward - like our 8-bit ripple adder from\nlast episode.", "start": 83.29, "duration": 3.18}, {"text": "But we can also create circuits that loop\nback on themselves.", "start": 86.47, "duration": 3.19}, {"text": "Let\u2019s try taking an ordinary OR gate, and\nfeed the output back into one of its inputs", "start": 89.66, "duration": 4.53}, {"text": "and see what happens.", "start": 94.19, "duration": 1.04}, {"text": "First, let\u2019s set both inputs to 0.", "start": 95.23, "duration": 2.2}, {"text": "So 0 OR 0 is 0, and so this circuit always\noutputs 0.", "start": 97.43, "duration": 4.54}, {"text": "If we were to flip input A to 1.", "start": 101.97, "duration": 2.04}, {"text": "1 OR 0 is 1, so now the output of the OR gate\nis 1.", "start": 104.01, "duration": 4.4}, {"text": "A fraction of a second later, that loops back\naround into input B, so the OR gate sees that", "start": 108.41, "duration": 4.54}, {"text": "both of its inputs are now 1.", "start": 112.95, "duration": 1.72}, {"text": "1 OR 1 is still 1, so there is no change in\noutput.", "start": 114.67, "duration": 3.66}, {"text": "If we flip input A back to 0, the OR gate\nstill outputs 1.", "start": 118.33, "duration": 3.66}, {"text": "So now we've got a circuit that records a\n\u201c1\u201d for us.", "start": 121.99, "duration": 2.62}, {"text": "Except, we've got a teensy tiny problem - this\nchange is permanent!", "start": 124.61, "duration": 3.3}, {"text": "No matter how hard we try, there\u2019s no way\nto get this circuit to flip back from a 1", "start": 127.91, "duration": 4.73}, {"text": "to a 0.", "start": 132.64, "duration": 1.0}, {"text": "Now let\u2019s look at this same circuit, but\nwith an AND gate instead.", "start": 133.64, "duration": 2.859}, {"text": "We'll start inputs A and B both at 1.", "start": 136.499, "duration": 2.74}, {"text": "1 AND 1 outputs 1 forever.", "start": 139.24, "duration": 2.13}, {"text": "But, if we then flip input A to 0, because\nit\u2019s an AND gate, the output will go to 0.", "start": 141.37, "duration": 4.87}, {"text": "So this circuit records a 0, the opposite\nof our other circuit.", "start": 146.3, "duration": 3.52}, {"text": "Like before, no matter what input we apply\nto input A afterwards, the circuit will always output 0.", "start": 149.82, "duration": 5.1}, {"text": "Now we\u2019ve got circuits that can record both\n0s and 1s.", "start": 154.98, "duration": 3.24}, {"text": "The key to making this a useful piece of memory\nis to combine our two circuits into what is", "start": 158.23, "duration": 4.11}, {"text": "called the AND-OR Latch.", "start": 162.34, "duration": 1.759}, {"text": "It has two inputs, a \"set\" input, which sets\nthe output to a 1, and a \"reset\" input, which", "start": 164.099, "duration": 4.381}, {"text": "resets the output to a 0.", "start": 168.48, "duration": 1.92}, {"text": "If set and reset are both 0, the circuit just\noutputs whatever was last put in it.", "start": 170.4, "duration": 4.56}, {"text": "In other words, it remembers a single bit\nof information!", "start": 174.96, "duration": 3.24}, {"text": "Memory!", "start": 178.2, "duration": 1.24}, {"text": "This is called a \u201clatch\u201d because it \u201clatches\nonto\u201d a particular value and stays that way.", "start": 179.44, "duration": 4.3}, {"text": "The action of putting data into memory is\ncalled writing, whereas getting the data out", "start": 183.78, "duration": 4.74}, {"text": "is called reading.", "start": 188.52, "duration": 0.999}, {"text": "Ok, so we\u2019ve got a way to store a single\nbit of information!", "start": 189.519, "duration": 2.991}, {"text": "Great!", "start": 192.51, "duration": 1.0}, {"text": "Unfortunately, having two different wires\nfor input \u2013 set and reset \u2013 is a bit confusing.", "start": 193.51, "duration": 4.8}, {"text": "To make this a little easier to use, we really\nwant a single wire to input data, that we", "start": 198.31, "duration": 4.539}, {"text": "can set to either 0 or 1 to store the value.", "start": 202.849, "duration": 2.101}, {"text": "Additionally, we are going to need a wire\nthat enables the memory to be either available", "start": 204.95, "duration": 3.84}, {"text": "for writing or \u201clocked\u201d down --which is\ncalled the write enable line.", "start": 208.79, "duration": 4.11}, {"text": "By adding a few extra logic gates, we can\nbuild this circuit, which is called a Gated Latch", "start": 212.9, "duration": 4.48}, {"text": "since the \u201cgate\u201d can be opened or\nclosed.", "start": 217.4, "duration": 1.72}, {"text": "Now this circuit is starting to get a little\ncomplicated.", "start": 219.129, "duration": 2.61}, {"text": "We don\u2019t want to have to deal with all the\nindividual logic gates... so as before, we\u2019re", "start": 221.739, "duration": 3.2}, {"text": "going to bump up a level of abstraction, and\nput our whole Gated Latch circuit in a box", "start": 224.939, "duration": 4.04}, {"text": "-- a box that stores one bit.", "start": 228.979, "duration": 1.87}, {"text": "Let\u2019s test out our new component!", "start": 230.849, "duration": 2.04}, {"text": "Let\u2019s start everything at 0.", "start": 232.889, "duration": 1.761}, {"text": "If we toggle the Data wire from 0 to 1 or\n1 to 0, nothing happens - the output stays at 0.", "start": 234.65, "duration": 5.83}, {"text": "That\u2019s because the write enable wire is\noff, which prevents any change to the memory.", "start": 240.58, "duration": 3.62}, {"text": "So we need to \u201copen\u201d the \u201cgate\u201d by\nturning the write enable wire to 1.", "start": 244.209, "duration": 3.731}, {"text": "Now we can put a 1 on the data line to save\nthe value 1 to our latch.", "start": 247.95, "duration": 3.869}, {"text": "Notice how the output is now 1.", "start": 251.819, "duration": 2.191}, {"text": "Success!", "start": 254.01, "duration": 0.81}, {"text": "We can turn off the enable line and the output\nstays as 1.", "start": 254.82, "duration": 3.58}, {"text": "Once again, we can toggle the value on the\ndata line all we want, but the output will", "start": 258.4, "duration": 3.559}, {"text": "stay the same.", "start": 261.959, "duration": 1.0}, {"text": "The value is saved in memory.", "start": 262.959, "duration": 2.031}, {"text": "Now let\u2019s turn the enable line on again\nuse our data line to set the latch to 0.", "start": 264.99, "duration": 4.66}, {"text": "Done.", "start": 269.65, "duration": 1.0}, {"text": "Enable line off, and the output is 0.", "start": 270.65, "duration": 2.26}, {"text": "And it works!", "start": 272.91, "duration": 1.009}, {"text": "Now, of course, computer memory that only\nstores one bit of information isn\u2019t very", "start": 273.919, "duration": 3.271}, {"text": "useful -- definitely not enough to run Frogger.", "start": 277.19, "duration": 2.59}, {"text": "Or anything, really.", "start": 279.78, "duration": 1.52}, {"text": "But we\u2019re not limited to using only one\nlatch.", "start": 281.3, "duration": 2.18}, {"text": "If we put 8 latches side-by-side, we can store\n8 bits of information like an 8-bit number.", "start": 283.48, "duration": 4.79}, {"text": "A group of latches operating like this is\ncalled a register, which holds a single number,", "start": 288.27, "duration": 5.13}, {"text": "and the number of bits in a register is called\nits width.", "start": 293.4, "duration": 2.66}, {"text": "Early computers had 8-bit registers, then\n16, 32, and today, many computers have registers", "start": 296.06, "duration": 5.759}, {"text": "that are 64-bits wide.", "start": 301.819, "duration": 1.6}, {"text": "To write to our register, we first have to\nenable all of the latches.", "start": 303.419, "duration": 3.331}, {"text": "We can do this with a single wire that connects to all of their enable inputs, which we set to 1.", "start": 306.75, "duration": 5.03}, {"text": "We then send our data in using the 8 data\nwires, and then set enable back to 0, and", "start": 311.8, "duration": 5.52}, {"text": "the 8 bit value is now saved in memory.", "start": 317.32, "duration": 2.34}, {"text": "Putting latches side-by-side works ok for\na small-ish number of bits.", "start": 319.66, "duration": 3.76}, {"text": "A 64-bit register would need 64 wires running\nto the data pins, and 64 wires running to", "start": 323.43, "duration": 5.37}, {"text": "the outputs.", "start": 328.8, "duration": 1.17}, {"text": "Luckily we only need 1 wire to enable all\nthe latches, but that\u2019s still 129 wires.", "start": 329.97, "duration": 6.53}, {"text": "For 256 bits, we end up with 513 wires!", "start": 336.5, "duration": 4.16}, {"text": "The solution is a matrix!", "start": 340.66, "duration": 1.46}, {"text": "In this matrix, we don\u2019t arrange our latches\nin a row, we put them in a grid.", "start": 342.14, "duration": 4.0}, {"text": "For 256 bits, we need a 16 by 16 grid of latches\nwith 16 rows and columns of wires.", "start": 346.16, "duration": 6.36}, {"text": "To activate any one latch, we must turn on\nthe corresponding row AND column wire.", "start": 352.52, "duration": 4.47}, {"text": "Let\u2019s zoom in and see how this works.", "start": 356.99, "duration": 1.94}, {"text": "We only want the latch at the intersection\nof the two active wires to be enabled,", "start": 358.93, "duration": 3.83}, {"text": "but all of the other latches should stay disabled.", "start": 362.78, "duration": 2.96}, {"text": "For this, we can use our trusty AND gate!", "start": 365.78, "duration": 2.52}, {"text": "The AND gate will output a 1 only if the row\nand the column wires are both 1.", "start": 368.31, "duration": 4.4}, {"text": "So we can use this signal to uniquely select\na single latch.", "start": 372.71, "duration": 3.01}, {"text": "This row/column setup connects all our latches\nwith a single, shared, write enable wire.", "start": 375.72, "duration": 5.02}, {"text": "In order for a latch to become write enabled,\nthe row wire, the column wire, and the write", "start": 380.76, "duration": 3.96}, {"text": "enable wire must all be 1.", "start": 384.72, "duration": 1.64}, {"text": "That should only ever be true for one single\nlatch at any given time.", "start": 386.36, "duration": 3.5}, {"text": "This means we can use a single, shared wire\nfor data.", "start": 389.86, "duration": 2.97}, {"text": "Because only one latch will ever be write\nenabled, only one will ever save the data", "start": 392.83, "duration": 4.33}, {"text": "-- the rest of the latches will simply ignore\nvalues on the data wire because they are not", "start": 397.18, "duration": 3.36}, {"text": "write enabled.", "start": 400.55, "duration": 1.28}, {"text": "We can use the same trick with a read enable\nwire to read the data later, to get the data", "start": 401.83, "duration": 4.82}, {"text": "out of one specific latch.", "start": 406.65, "duration": 2.019}, {"text": "This means in total, for 256 bits of memory,\nwe only need 35 wires - 1 data wire, 1 write", "start": 408.669, "duration": 6.332}, {"text": "enable wire, 1 read enable wire, and 16 rows\nand columns for the selection.", "start": 415.001, "duration": 4.939}, {"text": "That\u2019s significant wire savings!", "start": 419.94, "duration": 1.81}, {"text": "But we need a way to uniquely specify each\nintersection.", "start": 421.75, "duration": 3.389}, {"text": "We can think of this like a city, where you\nmight want to meet someone at 12th avenue", "start": 425.139, "duration": 3.28}, {"text": "and 8th street -- that's an address that defines\nan intersection.", "start": 428.419, "duration": 3.111}, {"text": "The latch we just saved our one bit into has\nan address of row 12 and column 8.", "start": 431.53, "duration": 4.43}, {"text": "Since there is a maximum of 16 rows, we store the row address in a 4 bit number.", "start": 435.96, "duration": 4.92}, {"text": "12 is 1100 in binary.", "start": 440.88, "duration": 2.86}, {"text": "We can do the same for the column address: 8 is 1000 in binary.", "start": 443.74, "duration": 4.94}, {"text": "So the address for the particular latch we\njust used can be written as 11001000.", "start": 448.68, "duration": 6.479}, {"text": "To convert from an address into something\nthat selects the right row or column, we need", "start": 455.159, "duration": 3.871}, {"text": "a special component called a multiplexer -- which\nis the computer component with a pretty cool", "start": 459.03, "duration": 4.22}, {"text": "name at least compared to the ALU.", "start": 463.25, "duration": 2.11}, {"text": "Multiplexers come in all different sizes,\nbut because we have 16 rows, we need a 1 to", "start": 465.36, "duration": 4.7}, {"text": "16 multiplexer.", "start": 470.069, "duration": 0.991}, {"text": "It works like this.", "start": 471.069, "duration": 1.03}, {"text": "You feed it a 4 bit number, and it connects\nthe input line to a corresponding output line.", "start": 472.099, "duration": 4.581}, {"text": "So if we pass in 0000, it will select the\nvery first column for us.", "start": 476.68, "duration": 5.389}, {"text": "If we pass in 0001, the next column is selected,\nand so on.", "start": 482.069, "duration": 4.18}, {"text": "We need one multiplexer to handle our rows\nand another multiplexer to handle the columns.", "start": 486.249, "duration": 4.44}, {"text": "Ok, it\u2019s starting to get complicated again,\nso let\u2019s make our 256-bit memory its own component.", "start": 490.689, "duration": 5.951}, {"text": "Once again a new level of abstraction!", "start": 496.8, "duration": 8.16}, {"text": "It takes an 8-bit address for input - the\n4 bits for the column and 4 for the row.", "start": 504.98, "duration": 4.72}, {"text": "We also need write and read enable wires.", "start": 509.7, "duration": 2.52}, {"text": "And finally, we need just one data wire, which\ncan be used to read or write data.", "start": 512.22, "duration": 4.86}, {"text": "Unfortunately, even 256-bits of memory isn\u2019t\nenough to run much of anything, so we need", "start": 517.08, "duration": 5.0}, {"text": "to scale up even more!", "start": 522.089, "duration": 1.431}, {"text": "We\u2019re going to put them in a row.", "start": 523.53, "duration": 2.2}, {"text": "Just like with the registers.", "start": 525.73, "duration": 1.09}, {"text": "We\u2019ll make a row of 8 of them, so we can\nstore an 8 bit number - also known as a byte.", "start": 526.82, "duration": 4.889}, {"text": "To do this, we feed the exact same address\ninto all 8 of our 256-bit memory components", "start": 531.709, "duration": 5.501}, {"text": "at the same time, and each one saves one bit\nof the number.", "start": 537.21, "duration": 4.03}, {"text": "That means the component we just made can\nstore 256 bytes at 256 different addresses.", "start": 541.24, "duration": 6.64}, {"text": "Again, to keep things simple, we want to leave\nbehind this inner complexity.", "start": 547.9, "duration": 3.72}, {"text": "Instead of thinking of this as a series of\nindividual memory modules and circuits, we\u2019ll", "start": 551.62, "duration": 4.1}, {"text": "think of it as a uniform bank of addressable\nmemory.", "start": 555.72, "duration": 2.75}, {"text": "We have 256 addresses, and at each address,\nwe can read or write an 8-bit value.", "start": 558.47, "duration": 5.07}, {"text": "We\u2019re going to use this memory component\nnext episode when we build our CPU.", "start": 563.54, "duration": 4.57}, {"text": "The way that modern computers scale to megabytes\nand gigabytes of memory is by doing the same", "start": 568.11, "duration": 4.159}, {"text": "thing we\u2019ve been doing here -- keep packaging\nup little bundles of memory into larger, and", "start": 572.269, "duration": 4.161}, {"text": "larger, and larger arrangements.", "start": 576.43, "duration": 1.36}, {"text": "As the number of memory locations grow, our\naddresses have to grow as well.", "start": 577.79, "duration": 4.47}, {"text": "8 bits hold enough numbers to provide addresses for 256 bytes of our memory, but that\u2019s all.", "start": 582.26, "duration": 6.42}, {"text": "To address a gigabyte \u2013 or a billion bytes\nof memory \u2013 we need 32-bit addresses.", "start": 588.68, "duration": 5.22}, {"text": "An important property of this memory is that\nwe can access any memory location, at any", "start": 593.9, "duration": 4.16}, {"text": "time, and in a random order.", "start": 598.07, "duration": 1.819}, {"text": "For this reason, it\u2019s called Random-Access\nMemory or RAM.", "start": 599.889, "duration": 3.551}, {"text": "When you hear people talking about how much RAM a computer has - that's the computer\u2019s memory.", "start": 603.44, "duration": 4.1}, {"text": "RAM is like a human\u2019s short term or working\nmemory, where you keep track of things going", "start": 607.64, "duration": 3.9}, {"text": "on right now - like whether or not you had\nlunch or paid your phone bill.", "start": 611.54, "duration": 3.21}, {"text": "Here\u2019s an actual stick of RAM - with 8 memory\nmodules soldered onto the board.", "start": 614.75, "duration": 3.839}, {"text": "If we carefully opened up one of these modules\nand zoomed in, The first thing you would see", "start": 618.589, "duration": 3.481}, {"text": "are 32 squares of memory.", "start": 622.07, "duration": 1.41}, {"text": "Zoom into one of those squares, and we can\nsee each one is comprised of 4 smaller blocks.", "start": 623.48, "duration": 4.57}, {"text": "If we zoom in again, we get down to the matrix\nof individual bits.", "start": 628.05, "duration": 3.4}, {"text": "This is a matrix of 128 by 64 bits.", "start": 631.45, "duration": 3.31}, {"text": "That\u2019s 8192 bits in total.", "start": 634.76, "duration": 3.06}, {"text": "Each of our 32 squares has 4 matrices, so\nthat\u2019s 32 thousand, 7 hundred and 68 bits.", "start": 637.829, "duration": 6.091}, {"text": "And there are 32 squares in total.", "start": 643.93, "duration": 1.55}, {"text": "So all in all, that\u2019s roughly 1 million\nbits of memory in each chip.", "start": 645.48, "duration": 4.38}, {"text": "Our RAM stick has 8 of these chips, so in\ntotal, this RAM can store 8 millions bits,", "start": 649.86, "duration": 4.979}, {"text": "otherwise known as 1 megabyte.", "start": 654.84, "duration": 1.86}, {"text": "That\u2019s not a lot of memory these days -- this\nis a RAM module from the 1980\u2019s.", "start": 656.7, "duration": 3.94}, {"text": "Today you can buy RAM that has a gigabyte\nor more of memory - that\u2019s billions of bytes", "start": 660.65, "duration": 5.02}, {"text": "of memory.", "start": 665.67, "duration": 0.63}, {"text": "So, today, we built a piece of SRAM - Static\nRandom-Access Memory \u2013 which uses latches.", "start": 666.4, "duration": 4.6}, {"text": "There are other types of RAM, such as DRAM, Flash memory, and NVRAM.", "start": 671.02, "duration": 4.02}, {"text": "These are very similar in function to SRAM,\nbut use different circuits to store the individual", "start": 675.04, "duration": 4.299}, {"text": "bits -- for example, using different logic\ngates, capacitors, charge traps, or memristors.", "start": 679.34, "duration": 4.76}, {"text": "But fundamentally, all of these technologies\nstore bits of information in massively nested", "start": 684.1, "duration": 4.88}, {"text": "matrices of memory cells.", "start": 688.99, "duration": 2.01}, {"text": "Like many things in computing, the fundamental\noperation is relatively simple.. it\u2019s the", "start": 691.019, "duration": 4.641}, {"text": "layers and layers of abstraction that\u2019s\nmind blowing -- like a russian doll that", "start": 695.66, "duration": 4.511}, {"text": "keeps getting smaller and smaller and smaller.", "start": 700.18, "duration": 2.72}, {"text": "I\u2019ll see you next week.", "start": 702.9, "duration": 1.82}, {"text": "Credits", "start": 704.72, "duration": 21.76}]