[{"text": "Hi, I\u2019m Carrie Anne, and welcome to CrashCourse\nComputer Science!", "start": 3.06, "duration": 2.56}, {"text": "Over the past two episodes, we got our first\ntaste of programming in a high-level language,", "start": 5.62, "duration": 4.39}, {"text": "like Python or Java.", "start": 10.01, "duration": 1.38}, {"text": "We talked about different types of programming\nlanguage statements \u2013 like assignments,", "start": 11.39, "duration": 2.879}, {"text": "ifs, and loops \u2013 as well as putting statements\ninto functions that perform a computation,", "start": 14.269, "duration": 4.401}, {"text": "like calculating an exponent.", "start": 18.67, "duration": 1.66}, {"text": "Importantly, the function we wrote to calculate\nexponents is only one possible solution.", "start": 20.33, "duration": 4.269}, {"text": "There are other ways to write this function\n\u2013 using different statements in different", "start": 24.599, "duration": 2.99}, {"text": "orders \u2013 that achieve exactly the same numerical\nresult.", "start": 27.589, "duration": 2.75}, {"text": "The difference between them is the algorithm,\nthat is the specific steps used to complete", "start": 30.34, "duration": 4.08}, {"text": "the computation.", "start": 34.44, "duration": 0.72}, {"text": "Some algorithms are better than others even\nif they produce equal results.", "start": 35.16, "duration": 3.34}, {"text": "Generally, the fewer steps it takes to compute,\nthe better it is, though sometimes we care", "start": 38.52, "duration": 4.35}, {"text": "about other factors, like how much memory\nit uses.", "start": 42.87, "duration": 2.55}, {"text": "The term algorithm comes from Persian polymath\nMu\u1e25ammad ibn M\u016bs\u0101 al-Khw\u0101rizm\u012b who was", "start": 45.42, "duration": 4.22}, {"text": "one of the fathers of algebra more than a\nmillennium ago.", "start": 49.64, "duration": 2.689}, {"text": "The crafting of efficient algorithms \u2013 a\nproblem that existed long before modern computers", "start": 52.329, "duration": 3.721}, {"text": "\u2013 led to a whole science surrounding computation,\nwhich evolved into the modern discipline of\u2026", "start": 56.05, "duration": 4.79}, {"text": "you guessed it!", "start": 60.84, "duration": 1.0}, {"text": "Computer Science!", "start": 61.84, "duration": 0.92}, {"text": "INTRO", "start": 62.76, "duration": 9.2}, {"text": "One of the most storied algorithmic problems\nin all of computer science is sorting\u2026 as", "start": 71.97, "duration": 3.811}, {"text": "in sorting names or sorting numbers.", "start": 75.781, "duration": 2.509}, {"text": "Computers sort all the time.", "start": 78.29, "duration": 1.579}, {"text": "Looking for the cheapest airfare, arranging\nyour email by most recently sent, or scrolling", "start": 79.869, "duration": 3.971}, {"text": "your contacts by last name -- those all require\nsorting.", "start": 83.84, "duration": 3.309}, {"text": "You might think \u201csorting isn\u2019t so tough\u2026\nhow many algorithms can there possibly be?\u201d", "start": 87.149, "duration": 3.771}, {"text": "The answer is: a lot.", "start": 90.92, "duration": 1.58}, {"text": "Computer Scientists have spent decades inventing\nalgorithms for sorting, with cool names like", "start": 92.5, "duration": 3.68}, {"text": "Bubble Sort and Spaghetti Sort.", "start": 96.18, "duration": 2.13}, {"text": "Let\u2019s try sorting!", "start": 98.31, "duration": 1.47}, {"text": "Imagine we have a set of airfare prices to\nIndianapolis.", "start": 99.78, "duration": 2.67}, {"text": "We\u2019ll talk about how data like this is represented\nin memory next week, but for now, a series", "start": 102.45, "duration": 4.989}, {"text": "of items like this is called an array.", "start": 107.439, "duration": 2.121}, {"text": "Let\u2019s take a look at these numbers to help\nsee how we might sort this programmatically.", "start": 109.56, "duration": 3.15}, {"text": "We\u2019ll start with a simple algorithm.", "start": 112.71, "duration": 2.43}, {"text": "First, let\u2019s scan down the array to find\nthe smallest number.", "start": 115.14, "duration": 3.07}, {"text": "Starting at the top with 307.", "start": 118.21, "duration": 1.31}, {"text": "It\u2019s the only number we\u2019ve seen, so it\u2019s\nalso the smallest.", "start": 119.52, "duration": 3.55}, {"text": "The next is 239, that\u2019s smaller than 307,\nso it becomes our new smallest number.", "start": 123.07, "duration": 6.18}, {"text": "Next is 214, our new smallest number.", "start": 129.25, "duration": 2.7}, {"text": "250 is not, neither is 384, 299, 223 or 312.", "start": 131.95, "duration": 7.35}, {"text": "So we\u2019ve finished scanning all numbers,\nand 214 is the smallest.", "start": 139.3, "duration": 3.64}, {"text": "To put this into ascending order, we swap\n214 with the number in the top location.", "start": 142.94, "duration": 4.58}, {"text": "Great.", "start": 147.53, "duration": 1.0}, {"text": "We sorted one number!", "start": 148.53, "duration": 1.05}, {"text": "Now we repeat the same procedure, but instead\nof starting at the top, we can start one spot", "start": 149.58, "duration": 3.73}, {"text": "below.", "start": 153.31, "duration": 0.73}, {"text": "First we see 239, which we save as our new\nsmallest number.", "start": 154.04, "duration": 4.0}, {"text": "Scanning the rest of the array, we find 223\nis the next smallest, so we swap this with", "start": 158.04, "duration": 5.24}, {"text": "the number in the second spot.", "start": 163.28, "duration": 1.53}, {"text": "Now we repeat again, starting from the third\nnumber down.", "start": 164.81, "duration": 3.07}, {"text": "This time, we swap 239 with 307.", "start": 167.88, "duration": 3.32}, {"text": "This process continues until we get to the\nvery last number, and voila, the array is", "start": 171.2, "duration": 4.631}, {"text": "sorted and you\u2019re ready to book that flight\nto Indianapolis!", "start": 175.831, "duration": 2.399}, {"text": "The process we just walked through is one\nway \u2013 or one algorithm \u2013 for sorting an", "start": 178.23, "duration": 4.09}, {"text": "array.", "start": 182.32, "duration": 1.0}, {"text": "It\u2019s called Selection Sort -- and it\u2019s\npretty basic.", "start": 183.32, "duration": 1.93}, {"text": "Here\u2019s the pseudo-code.", "start": 185.25, "duration": 1.74}, {"text": "This function can be used to sort 8, 80, or\n80 million numbers - and once you've written", "start": 186.99, "duration": 4.56}, {"text": "the function, you can use it over and over\nagain.", "start": 191.55, "duration": 2.6}, {"text": "With this sort algorithm, we loop through\neach position in the array, from top to bottom,", "start": 194.15, "duration": 3.75}, {"text": "and then for each of those positions, we have\nto loop through the array to find the smallest", "start": 197.9, "duration": 3.4}, {"text": "number to swap.", "start": 201.3, "duration": 1.1}, {"text": "You can see this in the code, where one FOR\nloop is nested inside of another FOR loop.", "start": 202.4, "duration": 4.14}, {"text": "This means, very roughly, that if we want\nto sort N items, we have to loop N times,", "start": 206.54, "duration": 4.41}, {"text": "inside of which, we loop N times, for a grand\ntotal of roughly N times N loops...", "start": 210.95, "duration": 4.66}, {"text": "Or N squared.", "start": 215.61, "duration": 1.0}, {"text": "This relationship of input size to the number\nof steps the algorithm takes to run characterizes", "start": 216.61, "duration": 4.48}, {"text": "the complexity of the Selection Sort algorithm.", "start": 221.09, "duration": 3.04}, {"text": "It gives you an approximation of how fast,\nor slow, an algorithm is going to be.", "start": 224.13, "duration": 4.27}, {"text": "Computer Scientists write this order of growth\nin something known as \u2013 no joke \u2013 \u201cbig", "start": 228.4, "duration": 4.5}, {"text": "O notation\u201d.", "start": 232.91, "duration": 0.99}, {"text": "N squared is not particularly efficient.", "start": 233.91, "duration": 2.1}, {"text": "Our example array had n = 8 items, and 8 squared\nis 64.", "start": 236.01, "duration": 4.43}, {"text": "If we increase the size of our array from\n8 items to 80, the running time is now 80", "start": 240.44, "duration": 5.08}, {"text": "squared, which is 6,400.", "start": 245.52, "duration": 2.35}, {"text": "So although our array only grew by 10 times\n- from 8 to 80 \u2013 the running time increased", "start": 247.87, "duration": 3.99}, {"text": "by 100 times \u2013 from 64 to 6,400!", "start": 251.86, "duration": 4.25}, {"text": "This effect magnifies as the array gets larger.", "start": 256.11, "duration": 2.379}, {"text": "That\u2019s a big problem for a company like\nGoogle, which has to sort arrays with millions", "start": 258.489, "duration": 4.121}, {"text": "or billions of entries.", "start": 262.61, "duration": 1.35}, {"text": "So, you might ask, as a burgeoning computer scientist, is there a more efficient sorting algorithm?", "start": 263.96, "duration": 4.8}, {"text": "Let\u2019s go back to our old, unsorted array\nand try a different algorithm, merge sort.", "start": 268.78, "duration": 4.62}, {"text": "The first thing merge sort does is check if\nthe size of the array is greater than 1.", "start": 273.4, "duration": 3.46}, {"text": "If it is, it splits the array into two halves.", "start": 276.87, "duration": 2.669}, {"text": "Since our array is size 8, it gets split into\ntwo arrays of size 4.", "start": 279.54, "duration": 3.54}, {"text": "These are still bigger than size 1, so they\nget split again, into arrays of size 2, and", "start": 283.08, "duration": 4.48}, {"text": "finally they split into 8 arrays with 1 item\nin each.", "start": 287.569, "duration": 2.971}, {"text": "Now we are ready to merge, which is how \u201cmerge\nsort\u201d gets its name.", "start": 290.54, "duration": 3.02}, {"text": "Starting with the first two arrays, we read\nthe first \u2013 and only \u2013 value in them,", "start": 293.56, "duration": 3.46}, {"text": "in this case, 307 and 239.", "start": 297.02, "duration": 3.08}, {"text": "239 is smaller, so we take that value first.", "start": 300.1, "duration": 3.4}, {"text": "The only number left is 307, so we put that\nvalue second.", "start": 303.51, "duration": 3.61}, {"text": "We\u2019ve successfully merged two arrays.", "start": 307.13, "duration": 2.629}, {"text": "We now repeat this process for the remaining\npairs, putting them each in sorted order.", "start": 309.759, "duration": 3.851}, {"text": "Then the merge process repeats.", "start": 313.61, "duration": 1.77}, {"text": "Again, we take the first two arrays, and we\ncompare the first numbers in them.", "start": 315.38, "duration": 3.849}, {"text": "This time its 239 and 214.", "start": 319.229, "duration": 3.111}, {"text": "214 is lowest, so we take that number first.", "start": 322.34, "duration": 3.419}, {"text": "Now we look again at the first two numbers\nin both arrays: 239 and 250.", "start": 325.76, "duration": 5.42}, {"text": "239 is lower, so we take that number next.", "start": 331.18, "duration": 3.18}, {"text": "Now we look at the next two numbers: 307 and\n250.", "start": 334.37, "duration": 3.41}, {"text": "250 is lower, so we take that.", "start": 337.78, "duration": 2.5}, {"text": "Finally, we\u2019re left with just 307, so that\ngets added last.", "start": 340.28, "duration": 4.18}, {"text": "In every case, we start with two arrays, each\nindividually sorted, and merge them into a", "start": 344.46, "duration": 4.449}, {"text": "larger sorted array.", "start": 348.909, "duration": 1.401}, {"text": "We repeat the exact same merging process for\nthe two remaining arrays of size two.", "start": 350.31, "duration": 4.16}, {"text": "Now we have two sorted arrays of size 4.", "start": 354.47, "duration": 2.479}, {"text": "Just as before, we merge, comparing the first\ntwo numbers in each array, and taking the", "start": 356.949, "duration": 3.541}, {"text": "lowest.", "start": 360.49, "duration": 1.0}, {"text": "We repeat this until all the numbers are merged,\nand then our array is fully sorted again!", "start": 361.49, "duration": 3.73}, {"text": "The bad news is: no matter how many times\nwe sort these, you\u2019re still going to have", "start": 365.22, "duration": 3.74}, {"text": "to pay $214 to get to Indianapolis.", "start": 368.96, "duration": 2.979}, {"text": "Anyway, the \u201cBig O\u201d computational complexity\nof merge sort is N times the Log of N.", "start": 371.939, "duration": 4.5}, {"text": "The N comes from the number of times we need\nto compare and merge items, which is directly", "start": 376.439, "duration": 3.901}, {"text": "proportional to the number of items in the\narray.", "start": 380.34, "duration": 2.479}, {"text": "The Log N comes from the number of merge steps.", "start": 382.819, "duration": 2.431}, {"text": "In our example, we broke our array of 8 items\ninto 4, then 2, and finally 1.", "start": 385.25, "duration": 4.56}, {"text": "That\u2019s 3 splits.", "start": 389.81, "duration": 1.31}, {"text": "Splitting in half repeatedly like this has\na logarithmic relationship with the number", "start": 391.12, "duration": 3.3}, {"text": "of items - trust me!", "start": 394.42, "duration": 1.85}, {"text": "Log base 2 of 8 equals 3 splits.", "start": 396.27, "duration": 2.07}, {"text": "If we double the size of our array to 16 \u2013 that's\ntwice as many items to sort \u2013 it only increases", "start": 398.34, "duration": 4.629}, {"text": "the number of split steps by 1 since log base\n2 of 16 equals 4.", "start": 402.969, "duration": 3.991}, {"text": "Even if we increase the size of the array\nmore than a thousand times, from 8 items to", "start": 406.96, "duration": 3.419}, {"text": "8000 items, the number of split steps stays\npretty low.", "start": 410.379, "duration": 3.981}, {"text": "Log base 2 of 8000 is roughly 13.", "start": 414.36, "duration": 2.3}, {"text": "That's more, but not much more than 3 -- about\nfour times larger \u2013 and yet we\u2019re sorting", "start": 416.66, "duration": 4.68}, {"text": "a lot more numbers.", "start": 421.34, "duration": 1.189}, {"text": "For this reason, merge sort is much more efficient\nthan selection sort.", "start": 422.529, "duration": 3.901}, {"text": "And now I can put my ceramic cat collection\nin name order MUCH faster!", "start": 426.43, "duration": 3.699}, {"text": "There are literally dozens of sorting algorithms\nwe could review, but instead, I want to move", "start": 430.129, "duration": 4.061}, {"text": "on to my other favorite category of classic\nalgorithmic problems: graph search!", "start": 434.19, "duration": 3.979}, {"text": "A graph is a network of nodes connected by\nlines.", "start": 438.169, "duration": 2.671}, {"text": "You can think of it like a map, with cities\nand roads connecting them.", "start": 440.84, "duration": 2.84}, {"text": "Routes between these cities take different\namounts of time.", "start": 443.68, "duration": 2.68}, {"text": "We can label each line with what is called\na cost or weight.", "start": 446.36, "duration": 3.26}, {"text": "In this case, it\u2019s weeks of travel.", "start": 449.62, "duration": 1.889}, {"text": "Now let\u2019s say we want to find the fastest\nroute for an army at Highgarden to reach the", "start": 451.509, "duration": 3.641}, {"text": "castle at Winterfell.", "start": 455.15, "duration": 1.269}, {"text": "The simplest approach would just be to try\nevery single path exhaustively and calculate", "start": 456.42, "duration": 4.589}, {"text": "the total cost of each.", "start": 461.009, "duration": 1.331}, {"text": "That\u2019s a brute force approach.", "start": 462.46, "duration": 1.4}, {"text": "We could have used a brute force approach\nin sorting, by systematically trying every", "start": 463.87, "duration": 4.129}, {"text": "permutation of the array to check if it\u2019s\nsorted.", "start": 467.999, "duration": 2.98}, {"text": "This would have an N factorial complexity\n- that is the number of nodes, times one less,", "start": 470.979, "duration": 5.141}, {"text": "times one less than that, and so on until\n1.", "start": 476.12, "duration": 2.639}, {"text": "Which is way worse than even N squared.", "start": 478.759, "duration": 2.231}, {"text": "But, we can be way more clever!", "start": 480.99, "duration": 2.29}, {"text": "The classic algorithmic solution to this graph\nproblem was invented by one of the greatest", "start": 483.28, "duration": 3.65}, {"text": "minds in computer science practice and theory,\nEdsger Dijkstra, so it\u2019s appropriately named", "start": 486.93, "duration": 4.639}, {"text": "Dijkstra's algorithm.", "start": 491.569, "duration": 1.141}, {"text": "We start in Highgarden with a cost of 0, which\nwe mark inside the node.", "start": 492.71, "duration": 3.5}, {"text": "For now, we mark all other cities with question\nmarks - we don\u2019t know the cost of getting", "start": 496.21, "duration": 4.03}, {"text": "to them yet.", "start": 500.24, "duration": 1.0}, {"text": "Dijkstra's algorithm always starts with the\nnode with lowest cost.", "start": 501.24, "duration": 3.109}, {"text": "In this case, it only knows about one node,\nHighgarden, so it starts there.", "start": 504.349, "duration": 4.09}, {"text": "It follows all paths from that node to all\nconnecting nodes that are one step away, and", "start": 508.439, "duration": 4.221}, {"text": "records the cost to get to each of them.", "start": 512.66, "duration": 2.02}, {"text": "That completes one round of the algorithm.", "start": 514.68, "duration": 2.09}, {"text": "We haven\u2019t encountered Winterfell yet, so\nwe loop and run Dijkstra's algorithm again.", "start": 516.77, "duration": 3.68}, {"text": "With Highgarden already checked, the next\nlowest cost node is King's Landing.", "start": 520.45, "duration": 3.81}, {"text": "Just as before, we follow every unvisited\nline to any connecting cities.", "start": 524.26, "duration": 3.66}, {"text": "The line to The Trident has a cost of 5.", "start": 527.92, "duration": 2.32}, {"text": "However, we want to keep a running cost from\nHighgarden, so the total cost of getting to", "start": 530.24, "duration": 4.25}, {"text": "The Trident is 8 plus 5, which is 13 weeks.", "start": 534.49, "duration": 2.87}, {"text": "Now we follow the offroad path to Riverrun,\nwhich has a high cost of 25, for a total of 33.", "start": 537.36, "duration": 5.16}, {"text": "But we can see inside of Riverrun that we\u2019ve\nalready found a path with a lower cost of", "start": 542.6, "duration": 3.66}, {"text": "just 10.", "start": 546.27, "duration": 1.0}, {"text": "So we disregard our new path, and stick with\nthe previous, better path.", "start": 547.27, "duration": 3.25}, {"text": "We\u2019ve now explored every line from King's\nLanding and didn\u2019t find Winterfell, so we", "start": 550.52, "duration": 4.44}, {"text": "move on.", "start": 554.96, "duration": 1.0}, {"text": "The next lowest cost node is Riverrun, at\n10 weeks.", "start": 555.96, "duration": 2.72}, {"text": "First we check the path to The Trident, which\nhas a total cost of 10 plus 2, or 12.", "start": 558.68, "duration": 4.32}, {"text": "That\u2019s slightly better than the previous\npath we found, which had a cost of 13, so", "start": 563.0, "duration": 4.011}, {"text": "we update the path and cost to The Trident.", "start": 567.011, "duration": 2.079}, {"text": "There is also a line from Riverrun to Pyke\nwith a cost of 3.", "start": 569.09, "duration": 2.71}, {"text": "10 plus 3 is 13, which beats the previous\ncost of 14, and so we update Pyke's path and", "start": 571.8, "duration": 5.16}, {"text": "cost as well.", "start": 576.96, "duration": 1.0}, {"text": "That\u2019s all paths from Riverrun checked...\nso... you guessed it, Dijkstra's algorithm", "start": 577.96, "duration": 3.791}, {"text": "loops again.", "start": 581.751, "duration": 1.0}, {"text": "The node with the next lowest cost is The\nTrident and the only line from The Trident", "start": 582.751, "duration": 3.609}, {"text": "that we haven\u2019t checked is a path to Winterfell!", "start": 586.36, "duration": 2.83}, {"text": "It has a cost of 10, plus we need to add in\nthe cost of 12 it takes to get to The Trident,", "start": 589.19, "duration": 4.36}, {"text": "for a grand total cost of 22.", "start": 593.55, "duration": 2.13}, {"text": "We check our last path, from Pyke to Winterfell,\nwhich sums to 31.", "start": 595.68, "duration": 3.83}, {"text": "Now we know the lowest total cost, and also\nthe fastest route for the army to get there,", "start": 599.51, "duration": 4.39}, {"text": "which avoids King\u2019s Landing!", "start": 603.9, "duration": 1.44}, {"text": "Dijkstra's original algorithm, conceived in\n1956, had a complexity of the number of nodes", "start": 605.34, "duration": 4.52}, {"text": "in the graph squared.", "start": 609.86, "duration": 1.0}, {"text": "And squared, as we already discussed, is never\ngreat, because it means the algorithm can\u2019t", "start": 610.86, "duration": 3.69}, {"text": "scale to big problems - like the entire road\nmap of the United States.", "start": 614.55, "duration": 3.81}, {"text": "Fortunately, Dijkstra's algorithm was improved\na few years later to take the number of nodes", "start": 618.36, "duration": 4.14}, {"text": "in the graph, times the log of the number\nof nodes, PLUS the number of lines.", "start": 622.5, "duration": 4.2}, {"text": "Although this looks more complicated, it\u2019s\nactually quite a bit faster.", "start": 626.7, "duration": 3.44}, {"text": "Plugging in our example graph, with 6 cities\nand 9 lines, proves it.", "start": 630.14, "duration": 3.38}, {"text": "Our algorithm drops from 36 loops to around 14.", "start": 633.52, "duration": 3.04}, {"text": "As with sorting, there are innumerable graph search algorithms, with different pros and cons.", "start": 636.56, "duration": 5.12}, {"text": "Every time you use a service like Google Maps\nto find directions, an algorithm much like", "start": 641.68, "duration": 3.84}, {"text": "Dijkstra's is running on servers to figure\nout the best route for you.", "start": 645.52, "duration": 3.32}, {"text": "Algorithms are everywhere and the modern world\nwould not be possible without them.", "start": 648.84, "duration": 3.92}, {"text": "We touched only the very tip of the algorithmic\niceberg in this episode, but a central part", "start": 652.76, "duration": 4.39}, {"text": "of being a computer scientist is leveraging\nexisting algorithms and writing new ones when", "start": 657.15, "duration": 4.23}, {"text": "needed, and I hope this little taste has intrigued\nyou to SEARCH further.", "start": 661.38, "duration": 4.04}, {"text": "I\u2019ll see you next week.", "start": 665.42, "duration": 1.24}]