[{"text": "Hi, I\u2019m Carrie Ann and this is Crash Course Computer Science.", "start": 3.16, "duration": 2.7}, {"text": "So last episode, we talked about how numbers can be represented in binary.\nRepresenting", "start": 5.86, "duration": 3.72}, {"text": "Like, 00101010 is 42 in decimal.", "start": 9.58, "duration": 4.16}, {"text": "Representing  and storing numbers is an important function of a computer, but the real goal is computation,", "start": 13.74, "duration": 5.46}, {"text": "or manipulating numbers in a structured and purposeful way, like adding two numbers together.", "start": 19.2, "duration": 4.28}, {"text": "These operations are handled by a computer\u2019s Arithmetic and Logic Unit,", "start": 23.48, "duration": 3.58}, {"text": "but most people call it by its street name: the ALU.", "start": 27.06, "duration": 2.66}, {"text": "The ALU is the mathematical brain of a computer.", "start": 29.72, "duration": 2.94}, {"text": "When you understand an ALU\u2019s design and function, you\u2019ll understand a fundamental", "start": 32.66, "duration": 3.8}, {"text": "part of modern computers. It is THE thing\nthat does all of the computation in a computer,", "start": 36.46, "duration": 5.4}, {"text": "so basically everything uses it.", "start": 41.86, "duration": 2.0}, {"text": "First though, look at this beauty.", "start": 43.86, "duration": 1.76}, {"text": "This is perhaps the most famous ALU ever, the Intel 74181.", "start": 45.62, "duration": 5.28}, {"text": "When it was released in 1970, it was", "start": 50.9, "duration": 1.96}, {"text": "It was the first complete ALU that fit entirely inside of a single chip -", "start": 52.86, "duration": 4.64}, {"text": "Which was a huge engineering feat at the time.", "start": 57.58, "duration": 2.26}, {"text": "So today we\u2019re going to take those Boolean logic gates we learned about last week", "start": 59.84, "duration": 3.5}, {"text": "to build a simple ALU circuit with much of the same functionality as the 74181.", "start": 63.34, "duration": 5.2}, {"text": "And over the next few episodes we\u2019ll use", "start": 68.54, "duration": 1.96}, {"text": "this to construct a computer from scratch. So it\u2019s going to get a little bit complicated,", "start": 70.5, "duration": 3.659}, {"text": "but I think you guys can handle it.", "start": 74.16, "duration": 1.86}, {"text": "INTRO", "start": 76.06, "duration": 9.24}, {"text": "An ALU is really two units in one -- there\u2019s\nan arithmetic unit and a logic unit.", "start": 85.3, "duration": 4.98}, {"text": "Let's start with the arithmetic unit, which is responsible for handling all numerical operations in a", "start": 90.28, "duration": 4.56}, {"text": "computer, like addition and subtraction. It\nalso does a bunch of other simple things like", "start": 94.84, "duration": 4.72}, {"text": "add one to a number, which is called an increment operation, but we\u2019ll talk about those later.", "start": 99.56, "duration": 4.43}, {"text": "Today, we\u2019re going to focus on the pi\u00e8ce de r\u00e9sistance, the cr\u00e8me de la cr\u00e8me of", "start": 103.99, "duration": 3.97}, {"text": "operations that underlies almost everything else a computer does - adding two numbers together.", "start": 107.98, "duration": 4.46}, {"text": "We could build this circuit entirely out of", "start": 112.48, "duration": 1.74}, {"text": "individual transistors, but that would get\nconfusing really fast.", "start": 114.22, "duration": 3.36}, {"text": "So instead as we talked about in Episode 3 \u2013 we can use a high-level of abstraction and build our components", "start": 117.62, "duration": 5.72}, {"text": "out of logic gates, in this case: AND, OR,\nNOT and XOR gates.", "start": 123.34, "duration": 4.8}, {"text": "The simplest adding circuit that we can build takes two binary digits, and adds them together.", "start": 128.14, "duration": 4.79}, {"text": "So we have two inputs, A and B, and one output, which is the sum of those two digits.", "start": 132.93, "duration": 5.13}, {"text": "Just to clarify: A, B and the output are all single bits.", "start": 138.06, "duration": 3.66}, {"text": "There are only four possible input combinations.", "start": 141.86, "duration": 2.66}, {"text": "The first three are:\n0+0 = 0", "start": 144.52, "duration": 2.88}, {"text": "1+0 = 1\n0+1 = 1", "start": 147.4, "duration": 3.5}, {"text": "Remember that in binary, 1 is the same as\ntrue, and 0 is the same as false.", "start": 150.9, "duration": 4.52}, {"text": "So this set of inputs exactly matches the boolean logic of an XOR gate, and we can use it as", "start": 155.42, "duration": 4.3}, {"text": "our 1-bit adder.", "start": 159.72, "duration": 1.0}, {"text": "But the fourth input combination, 1 + 1,\nis a special case. 1 + 1 is 2 (obviously)", "start": 160.72, "duration": 5.58}, {"text": "but there\u2019s no 2 digit in binary, so as we talked about last episode, the result is", "start": 166.3, "duration": 3.88}, {"text": "0 and the 1 is carried to the next column. So the sum is really 10 in binary.", "start": 170.18, "duration": 4.75}, {"text": "Now, the output of our XOR gate is partially correct - 1 plus 1, outputs 0.", "start": 174.93, "duration": 5.35}, {"text": "But, we need an extra output wire for that carry bit.", "start": 180.28, "duration": 2.76}, {"text": "The carry bit is only \u201ctrue\u201d when the inputs are 1 AND 1, because that's the only", "start": 183.04, "duration": 3.94}, {"text": "time when the result (two) is bigger than\n1 bit can store\u2026 and conveniently we have", "start": 186.98, "duration": 3.71}, {"text": "a gate for that! An AND gate, which is\nonly true when both inputs are true, so", "start": 190.69, "duration": 4.401}, {"text": "we\u2019ll add that to our circuit too.", "start": 195.1, "duration": 2.12}, {"text": "And that's it. This circuit is called a half adder. It\u2019s", "start": 197.22, "duration": 2.76}, {"text": "It's not that complicated - just two logic gates - but let\u2019s abstract away even this level", "start": 199.98, "duration": 4.06}, {"text": "of detail and encapsulate our newly minted half adder as its own component, with two", "start": 204.04, "duration": 4.22}, {"text": "inputs - bits A and B - and two outputs, the sum and the carry bits.", "start": 208.26, "duration": 4.52}, {"text": "This takes us to another level of abstraction\u2026 heh\u2026 I feel like I say that a lot.", "start": 212.78, "duration": 4.06}, {"text": "I wonder if this is going to become a thing.", "start": 216.86, "duration": 1.26}, {"text": "Anyway, If you want to add more than 1 + 1", "start": 223.88, "duration": 2.6}, {"text": "we\u2019re going to need a \u201cFull Adder.\u201d That half-adder left us with a carry bit as output.", "start": 226.48, "duration": 4.28}, {"text": "That means that when we move\non to the next column in a multi-column addition,", "start": 230.76, "duration": 3.49}, {"text": "and every column after that, we are going to have to add three bits together, no two.", "start": 234.25, "duration": 4.75}, {"text": "A full adder is a bit more complicated - it", "start": 239.0, "duration": 1.98}, {"text": "takes three bits as inputs: A, B and C. So\nthe maximum possible input is 1 + 1 + 1,", "start": 240.98, "duration": 6.06}, {"text": "which equals 1 carry out 1, so we still\nonly need two output wires: sum and carry.", "start": 247.04, "duration": 5.04}, {"text": "We can build a full adder using half adders. To do this, we use a half adder to add A plus B", "start": 252.08, "duration": 5.36}, {"text": "just like before \u2013 but then feed that\nresult and input C into a second half adder.", "start": 257.44, "duration": 5.22}, {"text": "Lastly, we need a OR gate to check if either one of the carry bits was true.", "start": 262.67, "duration": 4.4}, {"text": "That\u2019s it, we just made a full adder! Again,we can go up a level of abstraction and wrap", "start": 267.07, "duration": 4.56}, {"text": "up this full adder as its own component. It\ntakes three inputs, adds them, and outputs", "start": 271.63, "duration": 4.83}, {"text": "the sum and the carry, if there is one.", "start": 276.46, "duration": 1.58}, {"text": "Armed with our new components, we can now build a circuit that takes two, 8-bit numbers", "start": 278.04, "duration": 4.1}, {"text": "\u2013 Let\u2019s call them A and B \u2013 and adds them together.", "start": 282.14, "duration": 2.2}, {"text": "Let\u2019s start with the very first bit of", "start": 284.34, "duration": 1.84}, {"text": "A and B, which we\u2019ll call A0 and B0. At\nthis point, there is no carry bit to deal", "start": 286.18, "duration": 4.9}, {"text": "with, because this is our first addition.\nSo we can use our half adder to add these", "start": 291.08, "duration": 4.23}, {"text": "two bits together. The output is sum0.\nNow we want to add A1 and B1 together.", "start": 295.31, "duration": 5.79}, {"text": "It's possible there was a carry from the previous addition of A0 and B0, so this time we need", "start": 301.1, "duration": 5.12}, {"text": "to use a full adder that also inputs the carry\nbit. We output this result as sum1.", "start": 306.22, "duration": 5.27}, {"text": "Then, we take any carry from this full adder, and run it into the next full adder that handles", "start": 311.49, "duration": 4.97}, {"text": "A2 and B2. And we just keep doing this in\na big chain until all 8 bits have been added.", "start": 316.46, "duration": 5.08}, {"text": "Notice how the carry bits ripple forward to\neach subsequent adder. For this reason,", "start": 321.54, "duration": 4.52}, {"text": "this is called an 8-bit ripple carry adder. Notice how our last full adder has a carry out.", "start": 326.06, "duration": 4.98}, {"text": "If there is a carry into the 9th bit, it means the sum of the two numbers is too large to fit into 8-bits.", "start": 332.68, "duration": 3.52}, {"text": "This is called an overflow.", "start": 336.2, "duration": 1.38}, {"text": "In general, an overflow occurs when the result of an addition is too large to be represented by the number of bits you are using.", "start": 337.58, "duration": 5.76}, {"text": "This can usually cause errors and unexpected behavior.", "start": 343.34, "duration": 2.43}, {"text": "Famously, the original PacMan arcade game used 8 bits to keep track of what level you were on.", "start": 345.77, "duration": 4.43}, {"text": "This meant that if you made it past level 255 \u2013 the largest number storablein 8 bits \u2013", "start": 350.2, "duration": 4.9}, {"text": "to level 256, the ALU overflowed.", "start": 355.1, "duration": 3.03}, {"text": "This caused a bunch of errors and glitches making the level unbeatable.", "start": 358.13, "duration": 3.41}, {"text": "The bug became a rite of passage for the greatest PacMan players.", "start": 361.54, "duration": 3.28}, {"text": "So if we want to avoid overflows, we can extend our circuit with more full adders, allowing", "start": 364.82, "duration": 4.74}, {"text": "us to add 16 or 32 bit numbers. This makes overflows less likely to happen, but at the", "start": 369.56, "duration": 5.42}, {"text": "expense of more gates. An additional downside is that it takes a little bit of time for", "start": 374.98, "duration": 4.44}, {"text": "each of the carries to ripple forward.", "start": 379.42, "duration": 1.98}, {"text": "Admittedly, not very much time, electrons move pretty fast, so we\u2019re talking about billionths of a second,", "start": 381.4, "duration": 5.0}, {"text": "but that\u2019s enough to make a difference in today\u2019s fast computers.", "start": 386.4, "duration": 2.72}, {"text": "For this reason, modern computers use a slightly different adding circuit called a \u2018carry-look-ahead\u2019 adder", "start": 389.12, "duration": 5.94}, {"text": "which is faster, but ultimately does exactly the same thing-- adds binary numbers.", "start": 395.06, "duration": 4.8}, {"text": "The ALU\u2019s arithmetic unit also has circuits for other math operations", "start": 399.86, "duration": 3.74}, {"text": "and in general these 8 operations are always supported.", "start": 403.6, "duration": 2.92}, {"text": "And like our adder, these other operations are built from individual logic gates.", "start": 406.54, "duration": 3.6}, {"text": "Interestingly, you may have noticed that there are no multiply and divide operations.", "start": 410.14, "duration": 4.32}, {"text": "That's because simple ALUs don\u2019t have a circuit for this, and instead just perform a series of additions.", "start": 414.46, "duration": 5.22}, {"text": "Let\u2019s say you want to multiply 12 by 5.", "start": 419.68, "duration": 2.2}, {"text": "That\u2019s the same thing as adding 12 to itself 5 times. So it would take 5 passes through", "start": 421.88, "duration": 4.62}, {"text": "the ALU to do this one multiplication. And\nthis is how many simple processors,", "start": 426.5, "duration": 4.46}, {"text": "like those in your thermostat, TV remote, and microwave, do multiplication.", "start": 430.96, "duration": 4.64}, {"text": "It\u2019s slow, but it gets the job done.", "start": 435.6, "duration": 1.62}, {"text": "However, fancier processors, like those in your laptop or smartphone,", "start": 437.22, "duration": 3.28}, {"text": "have arithmetic units with dedicated circuits for multiplication.", "start": 440.5, "duration": 3.1}, {"text": "And as you might expect, the circuit is more complicated than addition -- there\u2019s no", "start": 443.6, "duration": 4.27}, {"text": "magic, it just takes a lot more logic gates\n\u2013 which is why less expensive processors", "start": 447.87, "duration": 3.67}, {"text": "don\u2019t have this feature.", "start": 451.54, "duration": 1.14}, {"text": "Ok, let\u2019s move on to the other half of the ALU: the Logic Unit.", "start": 452.68, "duration": 4.04}, {"text": "Instead of arithmetic\noperations, the Logic Unit performs\u2026 well...", "start": 456.72, "duration": 2.98}, {"text": "logical operations, like AND, OR and NOT, which we\u2019ve talked about previously.", "start": 459.7, "duration": 4.36}, {"text": "It also performs simple numerical tests, like checking if a number is negative.", "start": 464.07, "duration": 3.61}, {"text": "For example, here\u2019s a circuit that tests\nif the output of the ALU is zero.", "start": 467.68, "duration": 3.92}, {"text": "It does this using a bunch of OR gates to see if any of the bits are 1.", "start": 471.66, "duration": 3.72}, {"text": "Even if one single bit is 1, we know the number can\u2019t be zero and then we use a final NOT gate to flip this", "start": 475.38, "duration": 6.08}, {"text": "input so the output is 1 only if the input number is 0.", "start": 481.46, "duration": 3.65}, {"text": "So that\u2019s a high level overview of what makes up an ALU. We even built several of", "start": 485.11, "duration": 4.08}, {"text": "the main components from scratch, like our ripple adder.", "start": 489.19, "duration": 2.43}, {"text": "As you saw, it\u2019s just a big bunch of logic gates connected in clever ways.", "start": 491.62, "duration": 3.06}, {"text": "Which brings us back to that ALU you admired so much at the beginning of the episode.", "start": 494.68, "duration": 4.06}, {"text": "The Intel 74181.", "start": 498.74, "duration": 2.32}, {"text": "Unlike the 8-bit ALU we made today, the 74181 could only handle 4-bit inputs,", "start": 501.22, "duration": 5.56}, {"text": "which means YOU BUILT AN ALU THAT\u2019S LIKE", "start": 506.78, "duration": 2.26}, {"text": "TWICE AS GOOD AS THAT SUPER FAMOUS ONE. WITH\nYOUR MIND! Well.. sort of.", "start": 509.08, "duration": 5.62}, {"text": "We didn\u2019t build the whole thing\u2026 but you get the idea.", "start": 514.7, "duration": 2.12}, {"text": "The 74181 used about 70 logic gates, and it couldn\u2019t multiply or divide.", "start": 516.82, "duration": 5.02}, {"text": "But it was a huge step forward in miniaturization, opening the doors to more capable and less expensive computers.", "start": 521.84, "duration": 5.7}, {"text": "This 4-bit ALU circuit is already a lot to take in,", "start": 527.54, "duration": 2.82}, {"text": "but our 8-bit ALU would require hundreds of logic gates to fully build and engineers", "start": 530.36, "duration": 4.459}, {"text": "don\u2019t want to see all that complexity when using an ALU, so they came up with a special", "start": 534.819, "duration": 4.31}, {"text": "symbol to wrap it all up, which looks like\na big \u2018V\u2019. Just another level of abstraction!", "start": 539.129, "duration": 5.031}, {"text": "Our 8-bit ALU has two inputs, A and B, each with 8 bits. We also need a way to specify what operation the ALU should perform,", "start": 549.44, "duration": 7.86}, {"text": "for example, addition or subtraction.", "start": 557.3, "duration": 2.4}, {"text": "For that, we use a 4-bit operation code.", "start": 559.7, "duration": 2.18}, {"text": "We\u2019ll talk about this more in a later episode, but in brief, 1000 might be the command", "start": 561.88, "duration": 5.1}, {"text": "to add, while 1100 is the command for subtract. Basically, the operation code tells the ALU", "start": 567.0, "duration": 6.279}, {"text": "what operation to perform. And the result of that operation on inputs A and B is an 8-bit output.", "start": 573.28, "duration": 5.32}, {"text": "ALUs also output a series of Flags, which are 1-bit outputs for particular states and statuses.", "start": 578.6, "duration": 5.16}, {"text": "For example, if we subtract two numbers, and the result is 0, our zero-testing circuit, the one we made earlier,", "start": 583.76, "duration": 6.5}, {"text": "sets the Zero Flag to True (1). This is useful if we are trying to determine if two numbers are are equal.", "start": 590.26, "duration": 5.04}, {"text": "If we wanted to test if A was less than B,", "start": 595.3, "duration": 2.44}, {"text": "we can use the ALU to calculate A subtract B and look to see if the Negative Flag was set to true.", "start": 597.74, "duration": 5.48}, {"text": "If it was, we know that A was\nsmaller than B.", "start": 603.22, "duration": 2.48}, {"text": "And finally, there\u2019s also a wire attached to the carry out on the adder we built,", "start": 605.7, "duration": 3.92}, {"text": "so if there is an overflow, we\u2019ll know about it. This is called the Overflow Flag.", "start": 609.62, "duration": 4.36}, {"text": "Fancier ALUs will have more flags, but these three flags are universal and frequently used.", "start": 613.98, "duration": 4.84}, {"text": "In fact, we\u2019ll be using them soon in a future episode.", "start": 618.84, "duration": 2.54}, {"text": "So now you know how your computer does all its basic mathematical operations digitally", "start": 621.38, "duration": 4.26}, {"text": "with no gears or levers required.", "start": 625.64, "duration": 1.8}, {"text": "We\u2019re going to use this ALU when we construct our CPU two episodes from now.", "start": 627.44, "duration": 4.14}, {"text": "But before that, our computer is going to need some memory! We'll talk about that next week.", "start": 631.6, "duration": 4.96}]