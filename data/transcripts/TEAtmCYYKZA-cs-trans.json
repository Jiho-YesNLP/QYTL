[{"text": "Hi, I\u2019m Carrie Anne, and welcome to CrashCourse\nComputer Science!", "start": 3.12, "duration": 2.68}, {"text": "Over the past five episodes, we\u2019ve worked\nup from text-based teletype interfaces to", "start": 5.8, "duration": 4.58}, {"text": "pixelated bitmapped graphics. Then, last episode,\nwe covered Graphical User Interfaces and all", "start": 10.38, "duration": 5.53}, {"text": "their \u201cOoey Gooey\u201d richness.", "start": 15.91, "duration": 1.19}, {"text": "All of these examples have been 2D. But of\ncourse \u201cwe are living in a 3D world, and", "start": 17.1, "duration": 4.75}, {"text": "I\u2019m a 3 dimensional girl!\u201d", "start": 21.85, "duration": 1.33}, {"text": "So today, we're going to talk about some fundamental\nmethods in 3D computer graphics and how you", "start": 23.18, "duration": 4.68}, {"text": "render them onto a 2D screen.", "start": 27.86, "duration": 1.62}, {"text": "INTRO", "start": 29.6, "duration": 9.34}, {"text": "As we discussed in episode 24 we can write functions that draw a line between any two points like A and B.", "start": 38.94, "duration": 6.02}, {"text": "By manipulating the X and Y coordinates of\npoints A and B, we can manipulate the line.", "start": 44.96, "duration": 4.82}, {"text": "In 3D graphics, points have not just two coordinates,\nbut three -- X, Y and Z. Or \u201czee\u201d but", "start": 49.78, "duration": 5.27}, {"text": "I\u2019m going to say \u201czed\u201d.", "start": 55.05, "duration": 1.17}, {"text": "Of course, we don\u2019t have X/Y/Z coordinates\non a 2D computer screen, so graphics algorithms", "start": 56.22, "duration": 4.999}, {"text": "are responsible for \u201cflattening\u201d 3D coordinates\nonto a 2D plane.", "start": 61.219, "duration": 4.041}, {"text": "This process is known as 3D Projection. Once\nall of the points have been converted from", "start": 65.26, "duration": 4.52}, {"text": "3D to 2D, we can use the regular 2D line drawing\nfunction to connect the dots\u2026 literally.", "start": 69.78, "duration": 5.76}, {"text": "This is called Wireframe Rendering.", "start": 75.54, "duration": 1.93}, {"text": "Imagine building a cube out of chopsticks,\nand shining a flashlight on it. The shadow", "start": 77.47, "duration": 4.03}, {"text": "it casts onto your wall \u2013 its projection\n\u2013 is flat. If you rotate the cube around,", "start": 81.5, "duration": 4.39}, {"text": "you can see it\u2019s a 3D object, even though\nit\u2019s a flat projection.", "start": 85.89, "duration": 4.05}, {"text": "This transformation from 3D to 2D is exactly\nwhat your computer is doing, just with a lot", "start": 89.94, "duration": 4.83}, {"text": "more math\u2026 and less chopsticks.", "start": 94.77, "duration": 2.04}, {"text": "There are several types of 3D Projection.\nWhat you\u2019re seeing right now is an Orthographic", "start": 96.81, "duration": 4.46}, {"text": "Projection, where, for example, the parallel\nsides in the cube appear as parallel in the", "start": 101.27, "duration": 4.75}, {"text": "projection.", "start": 106.02, "duration": 1.0}, {"text": "In the real 3D world through, parallel lines\nconverge as they get further from the viewer,", "start": 107.02, "duration": 3.89}, {"text": "like a road going to the horizon. This type\nof 3D projection is called Perspective Projection.", "start": 110.91, "duration": 5.13}, {"text": "It\u2019s the same process, just with different\nmath. Sometimes you want perspective and sometimes", "start": 116.04, "duration": 4.91}, {"text": "you don\u2019t -- the choice is up to the developer.", "start": 120.95, "duration": 2.66}, {"text": "Simple shapes, like cubes, are easily defined\nby straight lines. But for more complex shapes,", "start": 123.61, "duration": 5.039}, {"text": "triangles are better -- what are called polygons\nin 3D graphics.", "start": 128.649, "duration": 3.151}, {"text": "Look at this beautiful teapot made out of\npolygons. A collection of polygons like this", "start": 131.8, "duration": 4.6}, {"text": "is a mesh.", "start": 136.409, "duration": 1.0}, {"text": "The denser the mesh, the smoother the curves\nand the finer the details. But, that also", "start": 137.409, "duration": 3.83}, {"text": "increases the polygon count, which means more\nwork for the computer.", "start": 141.239, "duration": 3.58}, {"text": "Game designers have to carefully balance model\nfidelity vs. polygon count, because if the", "start": 144.819, "duration": 5.0}, {"text": "count goes too high, the framerate of an animation\ndrops below what users perceive as smooth.", "start": 149.819, "duration": 4.78}, {"text": "For this reason, there are algorithms for\nsimplifying meshes.", "start": 154.599, "duration": 3.4}, {"text": "The reason triangles are used, and not squares,\nor polygons, or some other more complex shape", "start": 157.999, "duration": 4.32}, {"text": "is simplicity: three points in space unambiguously\ndefine a plane.", "start": 162.319, "duration": 4.581}, {"text": "If you give me three points in a 3D space,\nI can draw a plane through it - there is only", "start": 166.9, "duration": 4.729}, {"text": "one.. single.. answer.", "start": 171.629, "duration": 1.25}, {"text": "This isn\u2019t guaranteed to be true for shapes\nwith four or more points. Also, two points", "start": 172.879, "duration": 4.17}, {"text": "aren\u2019t enough to define a plane, only a\nline, so three is the perfect and minimal", "start": 177.049, "duration": 4.44}, {"text": "number. Triangles for the win!", "start": 181.489, "duration": 2.11}, {"text": "Wireframe rendering is cool and all \u2013 sorta\nretro \u2013 but of course 3D graphics can also", "start": 183.599, "duration": 4.581}, {"text": "be filled.", "start": 188.18, "duration": 1.0}, {"text": "The classic algorithm for doing this is called\nScanline Rendering, first developed in 1967", "start": 189.18, "duration": 4.619}, {"text": "at the University of Utah. For a simple example,\nlet\u2019s consider just one polygon.", "start": 193.799, "duration": 5.291}, {"text": "Our job here is to figure out how this polygon\ntranslates to filled pixels on a computer", "start": 199.09, "duration": 4.429}, {"text": "screen, so let\u2019s first overlay a grid of\npixels to fill.", "start": 203.519, "duration": 2.981}, {"text": "The scanline algorithm starts by reading the\nthree points that make up the polygon, and", "start": 206.5, "duration": 4.299}, {"text": "finding the lowest and highest Y values. It\nwill only consider rows between these two", "start": 210.799, "duration": 4.39}, {"text": "points.", "start": 215.189, "duration": 1.0}, {"text": "Then, the algorithm works down one row at\na time. In each row, it calculates where a", "start": 216.189, "duration": 3.871}, {"text": "line \u2013 running through the center of a row\n\u2013 intersects with the side of the polygon.", "start": 220.06, "duration": 4.399}, {"text": "Because polygons are triangles, if you intersect\none line, you have to intersect with another.", "start": 224.459, "duration": 4.881}, {"text": "It\u2019s guaranteed! The job of the scanline\nalgorithm is to fill in the pixels between", "start": 229.34, "duration": 4.369}, {"text": "the two intersections. Let\u2019s see how this\nworks.", "start": 233.709, "duration": 2.691}, {"text": "On the first row we look at we intersect here\nand here.", "start": 236.4, "duration": 3.169}, {"text": "The algorithm then colors in all pixels between\nthose two intersections.", "start": 239.569, "duration": 3.78}, {"text": "And this just continues, row by row, which\nis why it\u2019s called Scan... Line... Rendering.", "start": 243.349, "duration": 4.741}, {"text": "When we hit the bottom of the polygon, we\u2019re\ndone. The rate at which a computer fills in", "start": 248.09, "duration": 3.64}, {"text": "polygons is called the fillrate.", "start": 251.73, "duration": 2.049}, {"text": "Admittedly, this is a pretty ugly filled polygon.\nIt has what are known as \u201cJaggies\u201d -- those", "start": 253.779, "duration": 4.511}, {"text": "rough edges. This effect is less pronounced\nwhen using smaller pixels. But nonetheless,", "start": 258.29, "duration": 4.82}, {"text": "you see these in games all the time, especially\non lower powered platforms.", "start": 263.11, "duration": 3.66}, {"text": "One method to soften this effect is Antialiasing.\nInstead of filling pixels in a polygon with", "start": 266.77, "duration": 4.39}, {"text": "the same color, we can adjust the color based\non how much the polygon cuts through each", "start": 271.16, "duration": 4.569}, {"text": "pixel.", "start": 275.729, "duration": 1.0}, {"text": "If a pixel is entirely inside of a polygon,\nit gets fully colored. But if the polygon", "start": 276.729, "duration": 4.181}, {"text": "only grazes a pixel, it\u2019ll get a lighter\nshade. This feathering of the edges is much", "start": 280.91, "duration": 4.409}, {"text": "more pleasant to the eyes.", "start": 285.319, "duration": 1.56}, {"text": "Antialiasing is used all over the place, including\nin 2D graphics, like fonts and icons. If you", "start": 286.879, "duration": 5.181}, {"text": "lean in real close to your monitor.. Closer\u2026\ncloser\u2026. Closer!", "start": 292.06, "duration": 3.329}, {"text": "You\u2019ll see all the fonts in your browser\nare Antialiased. So smooth!", "start": 295.389, "duration": 3.751}, {"text": "In a 3D scene, there are polygons that are\npart objects in the back, near the front,", "start": 299.14, "duration": 4.649}, {"text": "and just about everywhere. Only some are visible,\nbecause some objects are hidden behind other", "start": 303.789, "duration": 4.541}, {"text": "objects in the scene -- what\u2019s called occlusion.", "start": 308.33, "duration": 2.63}, {"text": "The most straightforward way to handle this\nis to use a sort algorithm, and arrange all", "start": 310.96, "duration": 3.97}, {"text": "the polygons in the scene from farthest to\nnearest, then render them in that order.", "start": 314.93, "duration": 4.13}, {"text": "This is called the Painter's Algorithm, because\npainters also have to start with the background,", "start": 319.06, "duration": 4.18}, {"text": "and then increasingly work up to foreground\nelements.", "start": 323.24, "duration": 2.72}, {"text": "Consider this example scene with three overlapping\npolygons.", "start": 325.96, "duration": 3.16}, {"text": "To make things easier to follow, we\u2019re going\nto color the polygons differently. Also for", "start": 329.12, "duration": 4.449}, {"text": "simplicity, we\u2019ll assume these polygons\nare all parallel to the screen, but in a real", "start": 333.569, "duration": 4.481}, {"text": "program, like a game, the polygons can be\ntilted in 3D space.", "start": 338.05, "duration": 3.47}, {"text": "Our three polygons, A B and C\u2026 are at distance\n20, 12 and 14.", "start": 341.52, "duration": 4.76}, {"text": "The first thing the Painter\u2019s Algorithm\ndoes is sort all the polygons, from farthest", "start": 346.28, "duration": 3.54}, {"text": "to nearest.", "start": 349.82, "duration": 1.0}, {"text": "Now that they\u2019re in order, we can use scanline\nrendering to fill each polygon, one at a time.", "start": 350.82, "duration": 4.81}, {"text": "We start with Polygon A, the farthest one\naway.", "start": 355.63, "duration": 2.21}, {"text": "Then we repeat the process for the next farthest\npolygon, in this case, C.", "start": 357.84, "duration": 4.0}, {"text": "And then we repeat this again, for Polygon\nB.", "start": 361.84, "duration": 1.97}, {"text": "Now we\u2019re all done, and you can see the\nordering is correct. The polygons that are", "start": 363.81, "duration": 4.329}, {"text": "closer, are in front!", "start": 368.139, "duration": 1.06}, {"text": "An alternative method for handling occlusion\nis called Z-Buffering. It achieves the same", "start": 369.199, "duration": 4.361}, {"text": "output as before, but with a different algorithm.", "start": 373.56, "duration": 2.16}, {"text": "Let\u2019s go back to our previous example, before\nit was sorted. That\u2019s because this algorithm", "start": 375.72, "duration": 4.811}, {"text": "doesn\u2019t need to sort any polygons, which\nmakes it faster.", "start": 380.531, "duration": 2.929}, {"text": "In short, Z-buffering keeps track of the closest\ndistance to a polygon for every pixel in the", "start": 383.46, "duration": 4.489}, {"text": "scene. It does this by maintaining a Z-Buffer,\nwhich is just a matrix of values that sits", "start": 387.949, "duration": 5.0}, {"text": "in memory.", "start": 392.949, "duration": 1.0}, {"text": "At first, every pixel is initialized to infinity.", "start": 393.949, "duration": 2.521}, {"text": "Then Z-buffering starts with the first polygon\nin its list. In this case, that\u2019s A.", "start": 396.47, "duration": 4.819}, {"text": "It follows the same logic as the scanline\nalgorithm, but instead of coloring in pixels,", "start": 401.289, "duration": 4.201}, {"text": "it checks the distance of the polygon versus\nwhat\u2019s recorded in its Z-Buffer.", "start": 405.49, "duration": 3.989}, {"text": "It records the lower of the two values. For\nour Polygon A, with a distance of 20, it wins", "start": 409.479, "duration": 4.781}, {"text": "against infinity every time.", "start": 414.26, "duration": 1.95}, {"text": "When it\u2019s done with Polygon A, it moves\non to the next polygon in its list, and the", "start": 416.21, "duration": 3.91}, {"text": "same thing happens.", "start": 420.12, "duration": 1.099}, {"text": "Now, because we didn\u2019t sort the polygons,\nit\u2019s not always the case that later polygons", "start": 421.219, "duration": 3.781}, {"text": "overwrite high values. In the case of Polygon\nC, only some of the values in the Z-buffer", "start": 425.0, "duration": 5.139}, {"text": "get new minimum distances.", "start": 430.139, "duration": 1.661}, {"text": "This completed Z-buffer is used in conjunction\nwith a fancier version of scanline rendering", "start": 431.8, "duration": 4.53}, {"text": "that not only tests for line intersection,\nbut also does a lookup to see if that pixel", "start": 436.33, "duration": 4.079}, {"text": "will even be visible in the final scene. If\nit\u2019s not, the algorithm skips it and moves", "start": 440.409, "duration": 4.811}, {"text": "on.", "start": 445.22, "duration": 1.0}, {"text": "An interesting problem arises when two polygons\nhave the same distance, like if Polygon A", "start": 446.22, "duration": 4.09}, {"text": "and B are both at a distance of 20. Which\none do you draw on top?", "start": 450.31, "duration": 4.539}, {"text": "Polygons are constantly being shuffled around\nin memory and changing their access order.", "start": 454.849, "duration": 4.151}, {"text": "Plus, rounding errors are inherent in floating\npoint computations. So, which one gets drawn", "start": 459.0, "duration": 4.69}, {"text": "on top is often unpredictable.", "start": 463.69, "duration": 1.58}, {"text": "The result is a flickering effect called Z-Fighting,\nwhich if you\u2019ve played 3D games, you\u2019ve", "start": 465.27, "duration": 4.97}, {"text": "no doubt encountered.\nSpeaking of glitches, another common optimization", "start": 470.24, "duration": 3.239}, {"text": "in 3D graphics is called Back-Face Culling.", "start": 473.479, "duration": 2.481}, {"text": "If you think about it, a triangle has two\nsides, a front and a back. With something", "start": 475.96, "duration": 4.139}, {"text": "like the head of an avatar, or the ground\nin a game, you should only ever see one side", "start": 480.099, "duration": 3.991}, {"text": "-- the side facing outwards.", "start": 484.09, "duration": 2.0}, {"text": "So to save processing time, the back-side\nof polygons are often ignored in the rendering", "start": 486.09, "duration": 4.229}, {"text": "pipeline, which cuts the number of polygon\nfaces to consider in half.", "start": 490.319, "duration": 3.811}, {"text": "This is great, except when there\u2019s a bug\nthat lets you get inside of those objects,", "start": 494.13, "duration": 3.8}, {"text": "and look outwards. Then the avatar head or\nground becomes invisible.", "start": 497.93, "duration": 3.37}, {"text": "Moving on. We need to talk about lighting\n-- also known as shading -- because if it\u2019s", "start": 501.3, "duration": 4.79}, {"text": "a 3D scene, the lighting should vary over\nthe surface of objects.", "start": 506.09, "duration": 3.38}, {"text": "Let\u2019s go back to our teapot mesh.", "start": 509.47, "duration": 2.06}, {"text": "With scanline rendering coloring in all the\npolygons, our teapot looks like this. Not", "start": 511.53, "duration": 4.06}, {"text": "very 3D.", "start": 515.59, "duration": 1.0}, {"text": "So, let\u2019s add some lighting to enhance the\nrealism!", "start": 516.59, "duration": 2.71}, {"text": "As an example, we\u2019ll pick 3 polygons from\ndifferent parts of our teapot.", "start": 519.3, "duration": 3.9}, {"text": "Unlike our previous examples, we\u2019re now\ngoing to consider how these polygons are oriented", "start": 523.2, "duration": 4.09}, {"text": "in 3D space -- they\u2019re no longer parallel\nto the screen, but rather tilted in different", "start": 527.29, "duration": 4.9}, {"text": "3D directions.", "start": 532.19, "duration": 1.18}, {"text": "The direction they face is called the Surface\nNormal, and we can visualize that direction", "start": 533.37, "duration": 4.31}, {"text": "with a little 3D arrow that\u2019s perpendicular\nto the polygon\u2019s surface.", "start": 537.68, "duration": 3.92}, {"text": "Now let\u2019s add a light source.", "start": 541.6, "duration": 1.72}, {"text": "Each polygon is going to be illuminated a\ndifferent amount. Some will appear brighter,", "start": 543.32, "duration": 3.88}, {"text": "because their angle causes more light to be\nreflected towards the viewer.", "start": 547.2, "duration": 3.0}, {"text": "For example, the bottom-most polygon is tilted\ndownwards, away from the light source, which", "start": 550.2, "duration": 4.6}, {"text": "means it\u2019s going to be dark.", "start": 554.8, "duration": 1.26}, {"text": "In a similar way, the rightmost polygon is\nslightly facing away from the light, so it", "start": 556.06, "duration": 3.91}, {"text": "will be partially illuminated.", "start": 559.97, "duration": 1.669}, {"text": "And finally, there\u2019s the upper-left polygon.\nIts angle means that it will reflect light", "start": 561.639, "duration": 3.901}, {"text": "from the light source towards our view.", "start": 565.54, "duration": 1.84}, {"text": "So, it\u2019ll appear bright.", "start": 567.38, "duration": 1.47}, {"text": "If we do this for every polygon, our teapot\nlooks like this which is much more realistic!", "start": 568.85, "duration": 4.919}, {"text": "This approach is called Flat Shading, and\nit\u2019s the most basic lighting algorithm.", "start": 573.769, "duration": 4.031}, {"text": "Unfortunately, it also makes all those polygon\nboundaries really noticeable and the mesh", "start": 577.8, "duration": 4.57}, {"text": "doesn\u2019t look smooth.", "start": 582.37, "duration": 1.089}, {"text": "For this reason, more advanced lighting algorithms\nwere developed, such as Gouraud Shading and", "start": 583.459, "duration": 4.611}, {"text": "Phong Shading. Instead of coloring in polygons\nusing just one colour, they vary the colour", "start": 588.07, "duration": 4.96}, {"text": "across the surface in clever ways, which results\nin much nicer output.", "start": 593.03, "duration": 3.929}, {"text": "We also need to talk about textures, which\nin graphics refers to the look of a surface,", "start": 596.959, "duration": 4.391}, {"text": "rather than its feel.", "start": 601.35, "duration": 1.51}, {"text": "Like with lighting, there are many algorithms\nwith all sorts of fancy effects. The simplest", "start": 602.86, "duration": 4.64}, {"text": "is texture mapping. To visualize this process,\nlet\u2019s go back to our single polygon.", "start": 607.5, "duration": 4.57}, {"text": "When we\u2019re filling this in, using scanline\nrendering, we can look up what color to use", "start": 612.07, "duration": 3.88}, {"text": "at every pixel according to a texture image\nsaved in memory. To do this, we need a mapping", "start": 615.95, "duration": 5.249}, {"text": "between the polygon\u2019s coordinates and the\ntexture\u2019s coordinates.", "start": 621.199, "duration": 3.13}, {"text": "Let\u2019s jump to the first pixel that scanline\nrendering needs to fill in.", "start": 624.329, "duration": 3.25}, {"text": "The texturing algorithm will consult the texture\nin memory, take the average color from the", "start": 627.579, "duration": 4.221}, {"text": "corresponding region, and fill the polygon\naccordingly.", "start": 631.8, "duration": 2.88}, {"text": "This process repeats for all pixels in the\npolygon, and that\u2019s how we get textures.", "start": 634.68, "duration": 4.339}, {"text": "If you combine all the techniques we\u2019ve\ntalked about this episode, you get a wonderfully", "start": 639.019, "duration": 3.57}, {"text": "funky little teapot.", "start": 642.589, "duration": 1.341}, {"text": "And this teapot can sit in an even bigger\nscene, comprised of millions of polygons.", "start": 643.93, "duration": 4.74}, {"text": "Rendering a scene like this takes a fair amount\nof computation. But importantly, it\u2019s the", "start": 648.67, "duration": 4.19}, {"text": "same type of calculations being performed\nover and over and over again for many millions", "start": 652.86, "duration": 4.33}, {"text": "of polygons \u2013 scanline filling, antialiasing,\nlighting, and texturing. However there are", "start": 657.19, "duration": 5.49}, {"text": "a couple of ways to make this much faster!", "start": 662.68, "duration": 2.37}, {"text": "First off, we can speed things up by having\nspecial hardware with extra bells and whistles", "start": 665.05, "duration": 3.87}, {"text": "just for these specific types of computations,\nmaking them lightning fast. And secondly,", "start": 668.92, "duration": 5.219}, {"text": "we can divide up a 3D scene into many smaller\nparts, and then render all the pieces in parallel,", "start": 674.139, "duration": 5.01}, {"text": "rather than sequentially.", "start": 679.149, "duration": 1.521}, {"text": "CPU\u2019s aren\u2019t designed for this, so they\naren\u2019t particularly fast. So, computer engineers", "start": 680.67, "duration": 4.18}, {"text": "created special processors just for graphics\n\u2013 a GPU, or Graphics Processing Unit.", "start": 684.85, "duration": 5.13}, {"text": "These can be found on graphics cards inside\nof your computer, along with RAM reserved", "start": 689.98, "duration": 4.539}, {"text": "for graphics. This is where all the meshes\nand textures live, allowing them to be accessed", "start": 694.519, "duration": 4.481}, {"text": "super fast by many different cores of the\nGPU all at once.", "start": 699.0, "duration": 3.589}, {"text": "A modern graphics card, like a GeForce GTX\n1080 TI, contains 3584 processing cores, offering", "start": 702.589, "duration": 8.521}, {"text": "massive parallelization. It can process hundreds\nof millions of polygons every second!", "start": 711.11, "duration": 4.909}, {"text": "Ok, that concludes our whistle stop tour of\n3D graphics. Next week, we switch topics entirely.", "start": 716.02, "duration": 5.64}, {"text": "I\u2019ll ping you then.", "start": 721.66, "duration": 1.7}]