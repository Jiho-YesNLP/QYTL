[{"vid": "-jjUoTiaSHw", "cid": "Ugz7vemil1siTvBam4F4AaABAg", "comment": "the answer is actually wrong in the latest python version", "votes": "1", "replies": "", "reply": false}, {"vid": "-jjUoTiaSHw", "cid": "UgyP1mWfY8_sI_O8xZV4AaABAg", "comment": "great teacher I am so jealous of students at MIT", "votes": "3", "replies": "", "reply": false}, {"vid": "-jjUoTiaSHw", "cid": "UgyK-kVA2Ia5FGDn4Bt4AaABAg", "comment": "lol notice the reference here. the lecture hall they were in was 26-100", "votes": "3", "replies": "", "reply": false}, {"vid": "-jjUoTiaSHw", "cid": "UgwQ5be9Seku87dsFUB4AaABAg", "comment": "Absolutely well done and definitely keep it up!!! \ud83d\udc4d\ud83d\udc4d\ud83d\udc4d\ud83d\udc4d\ud83d\udc4d", "votes": "3", "replies": "", "reply": false}, {"vid": "-jjUoTiaSHw", "cid": "Ugxr8vm9w-m6D48Lt7V4AaABAg", "comment": "Wait, I thought strings were immutable...", "votes": "0", "replies": "8", "reply": false}, {"vid": "-jjUoTiaSHw", "cid": "UgxCtHTmfShp_PB_lRR4AaABAg", "comment": "Meedaaam kya padhati jhakaaaasss", "votes": "0", "replies": "", "reply": false}, {"vid": "-jjUoTiaSHw", "cid": "Ugi9JXGlsLiSPHgCoAEC", "comment": "00:25", "votes": "10", "replies": "2", "reply": false}, {"vid": "-jjUoTiaSHw", "cid": "UggWe9X7zzCy7XgCoAEC", "comment": "thank you ,mit", "votes": "5", "replies": "", "reply": false}, {"vid": "-jjUoTiaSHw", "cid": "Ugxr8vm9w-m6D48Lt7V4AaABAg.9A_8XoCm7zP9AbZ4_M0miO", "comment": "That isn't really relevant here. To my understanding, what that means is that you can't change the contents of the memory once you created the variable, but you can still change the variable - doing so will result in it creating a new value somewhere else in the memory, leaving the original behind (instead of modifying it).  Someone correct me if I'm wrong.", "votes": "2", "replies": "", "reply": true}, {"vid": "-jjUoTiaSHw", "cid": "Ugxr8vm9w-m6D48Lt7V4AaABAg.9A_8XoCm7zP9Abj-VW3vSf", "comment": "\u200b\u00a0@bee_irl\u00a0 Right, so the variable can change but the string itself can't...", "votes": "1", "replies": "", "reply": true}, {"vid": "-jjUoTiaSHw", "cid": "Ugxr8vm9w-m6D48Lt7V4AaABAg.9A_8XoCm7zP9GjNxOk729H", "comment": ">>> a = \"Hello world\"\r >>> a\r 'Hello world'\r >>> a[0] = \"M\"                                           # attempting to modify the string.  Traceback (most recent call last):\r        # strings are immutable. Doesn't work.     File \"<pyshell#2>\", line 1, in <module>\r     a[0] = \"M\"  >>> a_new_variable = \"\"    # an empty string, assigned to a new variable name.      >>> a_new_variable += a[3:9]\r    # slicing \"a\". a_new_variable set to itself plus the slice information from \"a\".   >>> a_new_variable\r 'lolo wor'  So \"a_new_variable\" was \"created\", and \"a\" wasn't changed in place.  \"a\" is still Hello world   In other words, you can change a string by creating a whole new variable name, and assigning it to an altered version of the original string.", "votes": "1", "replies": "", "reply": true}, {"vid": "-jjUoTiaSHw", "cid": "Ugxr8vm9w-m6D48Lt7V4AaABAg.9A_8XoCm7zP9H8bhvTOh6j", "comment": "\u00a0@algemmegla9002\u00a0 to anyone from future reading along, there is one more point to algem's reply. This is how Python handles a mutable thing like lists vs how it handles immutable thing like strings. Lets say you create a string and assign it to a, >>a=\"hello\". python creates a string \"hello\" store it somewhere in memory and make variable a point to it. Now when you do >>b=\"hello\", python makes the new variable b point to the org string that was created before., meaning there is only one copy of \"hello\" in memory and both a and b point to it. This is how python works on immutable objects like strings. Also, as you can see from above, there is no way to change the string a=\"hello\" without affecting b. Hence Python blocks or doesn't allow to change strings.  But with mutable objects like lists,  when you first do a=[1,2,3,4] and then do b=[1,2,3,4] python has to create a new list [1,2,3,4] (other than the one already present in memory ) and then make the new variable b point to it. So now there are two distinct variables a and b pointing to 2 separate copies of [1,2,3,4].Hence you can can safely change list- a without affecting b. Pro tip- remember this when you write memory efficient programs in python, DON'T KEEP creating COPIES OF PREEXISTING LISTS. Based on the length of your org list, you might run of memory pretty soon and hang your system. Please scroll down and read section 10.10 and also10.11 over here- http://www.greenteapress.com/thinkpython/html/thinkpython011.html", "votes": "4", "replies": "", "reply": true}, {"vid": "-jjUoTiaSHw", "cid": "Ugxr8vm9w-m6D48Lt7V4AaABAg.9A_8XoCm7zP9HNGQMA5bPl", "comment": "\u00a0@sreehari563\u00a0 I see, so assigning a different variable name to the same string \"is not\" referring to the same string in memory. It points to a \"new copy\" of the original string. (Edit: Redaction below) In the case of lists and dictionaries, assigning a new variable name to the old variable name points to the \"same list or value:key pair\" in memory?  Thank you for clearing that up.  [Edit: **See below comments for follow up redaction on this topic.**]  Just to revisit Gabriel's question, I think the confusion is that you can take an empty string and assign index positions from a different string. But the act of assigning indexes from an \"old string\" to a \"new string\" is misleading and appears to be making changes or to mutate the new string.", "votes": "1", "replies": "", "reply": true}, {"vid": "-jjUoTiaSHw", "cid": "Ugxr8vm9w-m6D48Lt7V4AaABAg.9A_8XoCm7zP9HOBNTkej-V", "comment": "\u00a0@algemmegla9002\u00a0 After your reply comment, I got a little confused and decided to check and confirm from reliable sources and I realised to my horror that I was completely  wrong about how Python handles lists vs strings. Perhaps a little surprisingly its the  other way around and in my original comment, what I wrote for strings is actually true for lists and vice versa. You know, for a language widely considered the simplest, python do tend to get really confusing at times, at least in the hands of non-experts. I apologize wholeheartedly to you or anybody else for giving wrong information and creating confusions. I have edited my comment above to make it correct.  Like they say, always learn from the experts and hence I request you or anybody else to scroll down the link shared here of the very famous \"Think Python\" book by Allan Downey to section 10.10 Objects and values and then 10.11 Aliasing and read the two paragraphs there to resolve all your doubts.  Once again, sorry for the confusions. http://www.greenteapress.com/thinkpython/html/thinkpython011.html", "votes": "1", "replies": "", "reply": true}, {"vid": "-jjUoTiaSHw", "cid": "Ugxr8vm9w-m6D48Lt7V4AaABAg.9A_8XoCm7zP9HWq0457qea", "comment": "\u00a0@sreehari563\u00a0 Thank you", "votes": "1", "replies": "", "reply": true}, {"vid": "-jjUoTiaSHw", "cid": "Ugxr8vm9w-m6D48Lt7V4AaABAg.9A_8XoCm7zP9HjVeAHKdDg", "comment": "\u00a0@sreehari563\u00a0 That's alright. We're all on the same winding path to learning. At least it gives a chance to think and examine the abstract innerworkings more thoroughly. I'll have to visit your link later on and, hopefully, wrap my brain around the concept. I'm currently trying out Pygame tutorials on youtube. :D Thanks again.", "votes": "0", "replies": "", "reply": true}, {"vid": "-jjUoTiaSHw", "cid": "Ugi9JXGlsLiSPHgCoAEC.8STTkXTHQyH8bz1EPxjSSy", "comment": "Real MVP", "votes": "3", "replies": "", "reply": true}, {"vid": "-jjUoTiaSHw", "cid": "Ugi9JXGlsLiSPHgCoAEC.8STTkXTHQyH8igzUymZ1aZ", "comment": "Thanks !", "votes": "0", "replies": "", "reply": true}]